        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>WebGLRenderer Class / ThreeD Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="ThreeD" data-type="WebGLRenderer">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../ThreeD.html">ThreeD</a> &rsaquo; <a href="../ThreeD/WebGLRenderer.html">WebGLRenderer</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../CurveUtils.html">CurveUtils</a></h2><h2><div class="icon-library"></div><a href="../FontUtils.html">FontUtils</a></h2><h2><div class="icon-library"></div><a href="../GeometryUtils.html">GeometryUtils</a></h2><h2><div class="icon-library"></div><a href="../ImageUtils.html">ImageUtils</a></h2><h2><div class="icon-library"></div><a href="../SceneUtils.html">SceneUtils</a></h2><h2><div class="icon-library"></div><a href="../ShapeUtils.html">ShapeUtils</a></h2><h2><div class="icon-library"></div><a href="../ThreeD.html">ThreeD</a></h2><ul class="icon">
<li><a href="../ThreeD/AmbientLight.html"><div class="icon-class"></div>AmbientLight</a></li>
<li><a href="../ThreeD/ArcCurve.html"><div class="icon-class"></div>ArcCurve</a></li>
<li><a href="../ThreeD/ArrowHelper.html"><div class="icon-class"></div>ArrowHelper</a></li>
<li><a href="../ThreeD/AxisHelper.html"><div class="icon-class"></div>AxisHelper</a></li>
<li><a href="../ThreeD/Bone.html"><div class="icon-class"></div>Bone</a></li>
<li><a href="../ThreeD/BoundingBox.html"><div class="icon-class"></div>BoundingBox</a></li>
<li><a href="../ThreeD/BoundingSphere.html"><div class="icon-class"></div>BoundingSphere</a></li>
<li><a href="../ThreeD/Buffer.html"><div class="icon-class"></div>Buffer</a></li>
<li><a href="../ThreeD/BufferGeometry.html"><div class="icon-class"></div>BufferGeometry</a></li>
<li><a href="../ThreeD/Camera.html"><div class="icon-class"></div>Camera</a></li>
<li><a href="../ThreeD/CanvasRenderData.html"><div class="icon-class"></div>CanvasRenderData</a></li>
<li><a href="../ThreeD/CanvasRenderer.html"><div class="icon-class"></div>CanvasRenderer</a></li>
<li><a href="../ThreeD/CircleGeometry.html"><div class="icon-class"></div>CircleGeometry</a></li>
<li><a href="../ThreeD/ClosedSplineCurve3.html"><div class="icon-class"></div>ClosedSplineCurve3</a></li>
<li><a href="../ThreeD/Color.html"><div class="icon-class"></div>Color</a></li>
<li><a href="../ThreeD/ConvexGeometry.html"><div class="icon-class"></div>ConvexGeometry</a></li>
<li><a href="../ThreeD/CubeGeomSides.html"><div class="icon-class"></div>CubeGeomSides</a></li>
<li><a href="../ThreeD/CubeGeometry.html"><div class="icon-class"></div>CubeGeometry</a></li>
<li><a href="../ThreeD/CubeReflectionMapping.html"><div class="icon-class"></div>CubeReflectionMapping</a></li>
<li><a href="../ThreeD/CubeRefractionMapping.html"><div class="icon-class"></div>CubeRefractionMapping</a></li>
<li><a href="../ThreeD/CubicBezierCurve.html"><div class="icon-class"></div>CubicBezierCurve</a></li>
<li><a href="../ThreeD/CubicBezierCurve3.html"><div class="icon-class"></div>CubicBezierCurve3</a></li>
<li><a href="../ThreeD/Curve.html"><div class="icon-class"></div>Curve&lt;V&gt;</a></li>
<li><a href="../ThreeD/Curve2D.html"><div class="icon-class"></div>Curve2D</a></li>
<li><a href="../ThreeD/Curve3D.html"><div class="icon-class"></div>Curve3D</a></li>
<li><a href="../ThreeD/CurvePath.html"><div class="icon-class"></div>CurvePath</a></li>
<li><a href="../ThreeD/CylinderGeometry.html"><div class="icon-class"></div>CylinderGeometry</a></li>
<li><a href="../ThreeD/DataTexture.html"><div class="icon-class"></div>DataTexture</a></li>
<li><a href="../ThreeD/DirectionalLight.html"><div class="icon-class"></div>DirectionalLight</a></li>
<li><a href="../ThreeD/EllipseCurve.html"><div class="icon-class"></div>EllipseCurve</a></li>
<li><a href="../ThreeD/EventEmitter.html"><div class="icon-class"></div>EventEmitter</a></li>
<li><a href="../ThreeD/EventEmitterEvent.html"><div class="icon-class"></div>EventEmitterEvent</a></li>
<li><a href="../ThreeD/ExtrudeGeometry.html"><div class="icon-class"></div>ExtrudeGeometry</a></li>
<li><a href="../ThreeD/ExtrudeGeometryWorldUVGenerator.html"><div class="icon-class"></div>ExtrudeGeometryWorldUVGenerator</a></li>
<li><a href="../ThreeD/Face3.html"><div class="icon-class"></div>Face3</a></li>
<li><a href="../ThreeD/Face4.html"><div class="icon-class"></div>Face4</a></li>
<li><a href="../ThreeD/Fog.html"><div class="icon-class"></div>Fog</a></li>
<li><a href="../ThreeD/FogExp2.html"><div class="icon-class"></div>FogExp2</a></li>
<li><a href="../ThreeD/FogLinear.html"><div class="icon-class"></div>FogLinear</a></li>
<li><a href="../ThreeD/Frustum.html"><div class="icon-class"></div>Frustum</a></li>
<li><a href="../ThreeD/Geometry.html"><div class="icon-class"></div>Geometry</a></li>
<li><a href="../ThreeD/IFace3.html"><div class="icon-interface"></div>IFace3</a></li>
<li><a href="../ThreeD/IFace4.html"><div class="icon-interface"></div>IFace4</a></li>
<li><a href="../ThreeD/IMaterial.html"><div class="icon-interface"></div>IMaterial</a></li>
<li><a href="../ThreeD/IParticleMaterial.html"><div class="icon-interface"></div>IParticleMaterial</a></li>
<li><a href="../ThreeD/IRenderableFace3.html"><div class="icon-interface"></div>IRenderableFace3</a></li>
<li><a href="../ThreeD/IRenderableFace4.html"><div class="icon-interface"></div>IRenderableFace4</a></li>
<li><a href="../ThreeD/IRenderableObj.html"><div class="icon-interface"></div>IRenderableObj</a></li>
<li><a href="../ThreeD/ITextureMapMaterial.html"><div class="icon-interface"></div>ITextureMapMaterial</a></li>
<li><a href="../ThreeD/IVector2.html"><div class="icon-interface"></div>IVector2</a></li>
<li><a href="../ThreeD/IVector3.html"><div class="icon-interface"></div>IVector3</a></li>
<li><a href="../ThreeD/IVector4.html"><div class="icon-interface"></div>IVector4</a></li>
<li><a href="../ThreeD/IcosahedronGeometry.html"><div class="icon-class"></div>IcosahedronGeometry</a></li>
<li><a href="../ThreeD/ImageLoader.html"><div class="icon-class"></div>ImageLoader</a></li>
<li><a href="../ThreeD/ImmediateRenderObject.html"><div class="icon-class"></div>ImmediateRenderObject</a></li>
<li><a href="../ThreeD/Intersect.html"><div class="icon-class"></div>Intersect</a></li>
<li><a href="../ThreeD/JSONLoader.html"><div class="icon-class"></div>JSONLoader</a></li>
<li><a href="../ThreeD/LOD.html"><div class="icon-class"></div>LOD</a></li>
<li><a href="../ThreeD/LatheGeometry.html"><div class="icon-class"></div>LatheGeometry</a></li>
<li><a href="../ThreeD/LensFlare.html"><div class="icon-class"></div>LensFlare</a></li>
<li><a href="../ThreeD/Light.html"><div class="icon-class"></div>Light</a></li>
<li><a href="../ThreeD/Line.html"><div class="icon-class"></div>Line</a></li>
<li><a href="../ThreeD/LineBasicMaterial.html"><div class="icon-class"></div>LineBasicMaterial</a></li>
<li><a href="../ThreeD/LineCurve.html"><div class="icon-class"></div>LineCurve</a></li>
<li><a href="../ThreeD/LineCurve3.html"><div class="icon-class"></div>LineCurve3</a></li>
<li><a href="../ThreeD/LoadCompleteCallback.html"><div class="icon-interface"></div>LoadCompleteCallback</a></li>
<li><a href="../ThreeD/LoadProgressCallback.html"><div class="icon-interface"></div>LoadProgressCallback</a></li>
<li><a href="../ThreeD/LoadStartCallback.html"><div class="icon-interface"></div>LoadStartCallback</a></li>
<li><a href="../ThreeD/LoadedCallback.html"><div class="icon-interface"></div>LoadedCallback</a></li>
<li><a href="../ThreeD/Loader.html"><div class="icon-class"></div>Loader</a></li>
<li><a href="../ThreeD/Material.html"><div class="icon-class"></div>Material</a></li>
<li><a href="../ThreeD/Matrix3.html"><div class="icon-class"></div>Matrix3</a></li>
<li><a href="../ThreeD/Matrix4.html"><div class="icon-class"></div>Matrix4</a></li>
<li><a href="../ThreeD/Mesh.html"><div class="icon-class"></div>Mesh</a></li>
<li><a href="../ThreeD/MeshBasicMaterial.html"><div class="icon-class"></div>MeshBasicMaterial</a></li>
<li><a href="../ThreeD/MeshDepthMaterial.html"><div class="icon-class"></div>MeshDepthMaterial</a></li>
<li><a href="../ThreeD/MeshFaceMaterial.html"><div class="icon-class"></div>MeshFaceMaterial</a></li>
<li><a href="../ThreeD/MeshLambertMaterial.html"><div class="icon-class"></div>MeshLambertMaterial</a></li>
<li><a href="../ThreeD/MeshNormalMaterial.html"><div class="icon-class"></div>MeshNormalMaterial</a></li>
<li><a href="../ThreeD/MeshPhongMaterial.html"><div class="icon-class"></div>MeshPhongMaterial</a></li>
<li><a href="../ThreeD/MorphAnimMesh.html"><div class="icon-class"></div>MorphAnimMesh</a></li>
<li><a href="../ThreeD/Object3D.html"><div class="icon-class"></div>Object3D</a></li>
<li><a href="../ThreeD/OctahedronGeometry.html"><div class="icon-class"></div>OctahedronGeometry</a></li>
<li><a href="../ThreeD/OrthographicCamera.html"><div class="icon-class"></div>OrthographicCamera</a></li>
<li><a href="../ThreeD/ParametricGeometry.html"><div class="icon-class"></div>ParametricGeometry</a></li>
<li><a href="../ThreeD/Particle.html"><div class="icon-class"></div>Particle</a></li>
<li><a href="../ThreeD/ParticleBasicMaterial.html"><div class="icon-class"></div>ParticleBasicMaterial</a></li>
<li><a href="../ThreeD/ParticleCanvasMaterial.html"><div class="icon-class"></div>ParticleCanvasMaterial</a></li>
<li><a href="../ThreeD/ParticleCanvasMaterialProgram.html"><div class="icon-interface"></div>ParticleCanvasMaterialProgram</a></li>
<li><a href="../ThreeD/ParticleSystem.html"><div class="icon-class"></div>ParticleSystem</a></li>
<li><a href="../ThreeD/Path.html"><div class="icon-class"></div>Path</a></li>
<li><a href="../ThreeD/PathAction.html"><div class="icon-class"></div>PathAction</a></li>
<li><a href="../ThreeD/PerspectiveCamera.html"><div class="icon-class"></div>PerspectiveCamera</a></li>
<li><a href="../ThreeD/PlaneGeometry.html"><div class="icon-class"></div>PlaneGeometry</a></li>
<li><a href="../ThreeD/PointLight.html"><div class="icon-class"></div>PointLight</a></li>
<li><a href="../ThreeD/PolyhedronGeometry.html"><div class="icon-class"></div>PolyhedronGeometry</a></li>
<li><a href="../ThreeD/PolyhedronGeometryVertex.html"><div class="icon-class"></div>PolyhedronGeometryVertex</a></li>
<li><a href="../ThreeD/Program.html"><div class="icon-class"></div>Program</a></li>
<li><a href="../ThreeD/Projector.html"><div class="icon-class"></div>Projector</a></li>
<li><a href="../ThreeD/ProjectorRenderData.html"><div class="icon-class"></div>ProjectorRenderData</a></li>
<li><a href="../ThreeD/QuadraticBezierCurve.html"><div class="icon-class"></div>QuadraticBezierCurve</a></li>
<li><a href="../ThreeD/QuadraticBezierCurve3.html"><div class="icon-class"></div>QuadraticBezierCurve3</a></li>
<li><a href="../ThreeD/Quaternion.html"><div class="icon-class"></div>Quaternion</a></li>
<li><a href="../ThreeD/Ray.html"><div class="icon-class"></div>Ray</a></li>
<li><a href="../ThreeD/Rectangle.html"><div class="icon-class"></div>Rectangle</a></li>
<li><a href="../ThreeD/RenderInts.html"><div class="icon-class"></div>RenderInts</a></li>
<li><a href="../ThreeD/RenderableFace3.html"><div class="icon-class"></div>RenderableFace3</a></li>
<li><a href="../ThreeD/RenderableFace4.html"><div class="icon-class"></div>RenderableFace4</a></li>
<li><a href="../ThreeD/RenderableLine.html"><div class="icon-class"></div>RenderableLine</a></li>
<li><a href="../ThreeD/RenderableObject.html"><div class="icon-class"></div>RenderableObject</a></li>
<li><a href="../ThreeD/RenderableParticle.html"><div class="icon-class"></div>RenderableParticle</a></li>
<li><a href="../ThreeD/RenderableVertex.html"><div class="icon-class"></div>RenderableVertex</a></li>
<li><a href="../ThreeD/Renderer.html"><div class="icon-class"></div>Renderer</a></li>
<li><a href="../ThreeD/Ribbon.html"><div class="icon-class"></div>Ribbon</a></li>
<li><a href="../ThreeD/Scene.html"><div class="icon-class"></div>Scene</a></li>
<li><a href="../ThreeD/ShaderMaterial.html"><div class="icon-class"></div>ShaderMaterial</a></li>
<li><a href="../ThreeD/Shape.html"><div class="icon-class"></div>Shape</a></li>
<li><a href="../ThreeD/SkinnedMesh.html"><div class="icon-class"></div>SkinnedMesh</a></li>
<li><a href="../ThreeD/SphereGeometry.html"><div class="icon-class"></div>SphereGeometry</a></li>
<li><a href="../ThreeD/SphericalReflectionMapping.html"><div class="icon-class"></div>SphericalReflectionMapping</a></li>
<li><a href="../ThreeD/SphericalRefractionMapping.html"><div class="icon-class"></div>SphericalRefractionMapping</a></li>
<li><a href="../ThreeD/SplineCurve.html"><div class="icon-class"></div>SplineCurve</a></li>
<li><a href="../ThreeD/SplineCurve3.html"><div class="icon-class"></div>SplineCurve3</a></li>
<li><a href="../ThreeD/SpotLight.html"><div class="icon-class"></div>SpotLight</a></li>
<li><a href="../ThreeD/Sprite.html"><div class="icon-class"></div>Sprite</a></li>
<li><a href="../ThreeD/SpriteAlignment.html"><div class="icon-class"></div>SpriteAlignment</a></li>
<li><a href="../ThreeD/TetrahedronGeometry.html"><div class="icon-class"></div>TetrahedronGeometry</a></li>
<li><a href="../ThreeD/TextGeometry.html"><div class="icon-class"></div>TextGeometry</a></li>
<li><a href="../ThreeD/Texture.html"><div class="icon-class"></div>Texture</a></li>
<li><a href="../ThreeD/Three.html"><div class="icon-class"></div>Three</a></li>
<li><a href="../ThreeD/TorusGeometry.html"><div class="icon-class"></div>TorusGeometry</a></li>
<li><a href="../ThreeD/TorusKnotGeometry.html"><div class="icon-class"></div>TorusKnotGeometry</a></li>
<li><a href="../ThreeD/TubeGeometry.html"><div class="icon-class"></div>TubeGeometry</a></li>
<li><a href="../ThreeD/UV.html"><div class="icon-class"></div>UV</a></li>
<li><a href="../ThreeD/UVMapping.html"><div class="icon-class"></div>UVMapping</a></li>
<li><a href="../ThreeD/Uniform.html"><div class="icon-class"></div>Uniform</a></li>
<li><a href="../ThreeD/UniformsUtils.html"><div class="icon-class"></div>UniformsUtils</a></li>
<li><a href="../ThreeD/Vector2.html"><div class="icon-class"></div>Vector2</a></li>
<li><a href="../ThreeD/Vector3.html"><div class="icon-class"></div>Vector3</a></li>
<li><a href="../ThreeD/Vector4.html"><div class="icon-class"></div>Vector4</a></li>
<li><a href="../ThreeD/Vertex.html"><div class="icon-class"></div>Vertex</a></li>
<li><a href="../ThreeD/WebGLCamera.html"><div class="icon-class"></div>WebGLCamera</a></li>
<li><a href="../ThreeD/WebGLGeometry.html"><div class="icon-class"></div>WebGLGeometry</a></li>
<li><a href="../ThreeD/WebGLMaterial.html"><div class="icon-class"></div>WebGLMaterial</a></li>
<li><a href="../ThreeD/WebGLObject.html"><div class="icon-class"></div>WebGLObject</a></li>
<li><a href="../ThreeD/WebGLRenderTarget.html"><div class="icon-class"></div>WebGLRenderTarget</a></li>
<li><a href="../ThreeD/WebGLRenderTargetCube.html"><div class="icon-class"></div>WebGLRenderTargetCube</a></li>
<li><div class="icon-class"></div><strong>WebGLRenderer</strong></li>
<li><a href="../ThreeD/WebGLRendererInfo.html"><div class="icon-class"></div>WebGLRendererInfo</a></li>
<li><a href="../ThreeD/WebGLRendererMemoryInfo.html"><div class="icon-class"></div>WebGLRendererMemoryInfo</a></li>
<li><a href="../ThreeD/WebGLRendererRenderInfo.html"><div class="icon-class"></div>WebGLRendererRenderInfo</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../ThreeMath.html">ThreeMath</a></h2></div>
<div class="content">
        <h2><strong>WebGLRenderer</strong>
          Class
        </h2>
        
<div class="doc">

</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../ThreeD/Renderer.html">Renderer</a></span></p>
<h3>Constructors</h3>
<div class="method"><h4 id="WebGLRenderer">
<span class="show-code">Code</span>
new <strong>WebGLRenderer</strong>([<a href="http://api.dartlang.org/dart_html/CanvasElement.html">CanvasElement</a> canvas, <a href="http://api.dartlang.org/dart_core/String.html">String</a> precision = PRECISION_HIGH, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> alpha = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> premultipliedAlpha = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> antialias = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> stencil = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> preserveDrawingBuffer = false, <a href="http://api.dartlang.org/dart_core/num.html">num</a> clearColorHex = 0x000000, <a href="http://api.dartlang.org/dart_core/num.html">num</a> clearAlpha = 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxLights = 4]) <a class="anchor-link" href="#WebGLRenderer"
              title="Permalink to WebGLRenderer.WebGLRenderer">#</a></h4>
<div class="doc">

<pre class="source">
WebGLRenderer( [	this.canvas, 
					this.precision = PRECISION_HIGH, 
					this.alpha = true,
			      this.premultipliedAlpha = true,
		        this.antialias = true,
	          this.stencil = true,
					this.preserveDrawingBuffer = false,
					num clearColorHex = 0x000000,
					this.clearAlpha = 0,
					this.maxLights = 4] ) 
		: 	

		clearColor = new Color(clearColorHex),
		
			// clearing
			autoClear = true,
			autoClearColor = true,
			autoClearDepth = true,
			autoClearStencil = true,

			// scene graph
			sortObjects = true,
			autoUpdateObjects = true,
			autoUpdateScene = true,

			// physically based shading
			gammaInput = false,
			gammaOutput = false,
			physicallyBasedShading = false,

			// shadow map
			shadowMapEnabled = false,
			shadowMapAutoUpdate = true,
			shadowMapSoft = true,
			shadowMapCullFrontFaces = true,
			shadowMapDebug = false,
			shadowMapCascade = false,

			// morphs
			maxMorphTargets = 8,
			maxMorphNormals = 4,

			// flags
			autoScaleCubemaps = true,

			// custom render plugins
			renderPluginsPre = [],
			renderPluginsPost = [],

			info = new WebGLRendererInfo(),

			// internal properties

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,
	_geometryGroupCounter = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = 0,
	_viewportHeight = 0,
	_currentWidth = 0,
	_currentHeight = 0 ,

	// frustum
_frustum = new Frustum(),

 // camera matrices cache
_projScreenMatrix = new Matrix4(),
_projScreenMatrixPS = new Matrix4(),

_vector3 = new Vector4(),

// light arrays cache

_direction = new Vector3(),

_lightsNeedUpdate = true

{
		  
	  _lights = {

	    "ambient": [ 0, 0, 0 ],
	    "directional": { "length": 0, "colors": [], "positions": [] },
	    "point": { "length": 0, "colors": [], "positions": [], "distances": [] },
	    "spot": { "length": 0, "colors": [], "positions": [], "distances": [], "directions": [], "angles": [], "exponents": [] }

	  };
		 
	  
	  
  if (canvas == null) {
      canvas = new CanvasElement();
  }

	// initialize

	initGL();

	setDefaultGLState();


	// GPU capabilities

	maxVertexTextures = _gl.getParameter( WebGLRenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	  maxTextureSize = _gl.getParameter( WebGLRenderingContext.MAX_TEXTURE_SIZE );
	  maxCubemapSize = _gl.getParameter( WebGLRenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE );

	maxAnisotropy = (_glExtensionTextureFilterAnisotropic != null) ? _gl.getParameter( EXTTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	supportsVertexTextures = ( maxVertexTextures &gt; 0 );
	supportsBoneTextures = supportsVertexTextures &amp;&amp; (_glExtensionTextureFloat != null);


	// default plugins (order is important)

	//shadowMapPlugin = new ShadowMapPlugin();
	//addPrePlugin( shadowMapPlugin );

	//addPostPlugin( new SpritePlugin() );
	//addPostPlugin( new LensFlarePlugin() );
	
}
</pre>
</div>
</div>
<h3>Static Fields</h3>
<div class="field"><h4 id="PRECISION_HIGH">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>PRECISION_HIGH</strong> <a class="anchor-link"
            href="#PRECISION_HIGH"
            title="Permalink to WebGLRenderer.PRECISION_HIGH">#</a>
        </h4>
        <div class="doc">

<pre class="source">
static const String PRECISION_HIGH = 'highp';
</pre>
</div>
</div>
<h3>Methods</h3>
<div class="method"><h4 id="addBuffer">
<span class="show-code">Code</span>
<strong>addBuffer</strong>(objlist, <a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> buffer, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#addBuffer"
              title="Permalink to WebGLRenderer.addBuffer">#</a></h4>
<div class="doc">

<pre class="source">
addBuffer ( objlist, WebGLGeometry buffer, WebGLObject object ) {

	  object.buffer = buffer;
	  object.opaque = null;
	  object.transparent = null;
		objlist.add(object);

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addBufferImmediate">
<span class="show-code">Code</span>
<strong>addBufferImmediate</strong>(objlist, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#addBufferImmediate"
              title="Permalink to WebGLRenderer.addBufferImmediate">#</a></h4>
<div class="doc">

<pre class="source">
addBufferImmediate ( objlist, WebGLObject object ) {

	  object.opaque = null;
   object.transparent = null;
   
		objlist.add(object);

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addLineNumbers">
<span class="show-code">Code</span>
<strong>addLineNumbers</strong>(string) <a class="anchor-link" href="#addLineNumbers"
              title="Permalink to WebGLRenderer.addLineNumbers">#</a></h4>
<div class="doc">

<pre class="source">
addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		var il = chunks.length;
		for ( var i = 0; i &lt; il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = "${i + 1}:${chunks[i]}";

		}

		return chunks.join( "\n" );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addObject">
<span class="show-code">Code</span>
<strong>addObject</strong>(<a href="../ThreeD/Object3D.html">Object3D</a> object, <a href="../ThreeD/Scene.html">Scene</a> scene) <a class="anchor-link" href="#addObject"
              title="Permalink to WebGLRenderer.addObject">#</a></h4>
<div class="doc">

<pre class="source">
addObject ( Object3D object, Scene scene ) {

	  // nelsonsilva - wrapping in our own decorator
   WebGLObject webglobject = new WebGLObject(object);
   
   // ATTENTION - All type checks must be done with object and object.geometry
   WebGLGeometry geometry = webglobject.webglgeometry;
	  
		if (  !webglobject.__webglInit ) {

		  webglobject.__webglInit = true;

		  webglobject._modelViewMatrix = new Matrix4();
		  webglobject._normalMatrix = new Matrix3();

			if ( object is Mesh ) {

				if ( object.geometry is Geometry ) {

					if ( geometry.geometryGroups == null) {

						sortFacesByMaterial( geometry );

					}

					// create separate VBOs per geometry chunk

					geometry.geometryGroups.forEach((k, geometryGroup) {

						// initialise VBO on the first access

						if ( geometryGroup.__webglVertexBuffer == null ) {

							createMeshBuffers( geometryGroup );
							initMeshBuffers( geometryGroup, webglobject );

							geometry.verticesNeedUpdate = true;
							geometry.morphTargetsNeedUpdate = true;
							geometry.elementsNeedUpdate = true;
							geometry.uvsNeedUpdate = true;
							geometry.normalsNeedUpdate = true;
							geometry.tangentsNeedUpdate = true;
							geometry.colorsNeedUpdate = true;

						}

					});

				} else if ( object.geometry is BufferGeometry ) {

					initDirectBuffers( object.geometry as BufferGeometry);

				}

			} else if ( object is Ribbon ) {

				if( geometry.__webglVertexBuffer == null) {

					createRibbonBuffers( geometry );
					initRibbonBuffers( geometry );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			} else if ( object is Line ) {

				geometry = new WebGLGeometry.from(object.geometry);

				if( geometry.__webglVertexBuffer == null ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, webglobject );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			} else if ( object is ParticleSystem ) {

				if ( geometry.__webglVertexBuffer == null ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, webglobject );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( webglobject.__webglActive == null) {

			if ( object is Mesh ) {

				if ( object.geometry is BufferGeometry ) {

					addBuffer( scene["__webglObjects"], geometry, webglobject );

				} else {

				  geometry.geometryGroups.forEach( (k, geometryGroup) {

						addBuffer( scene["__webglObjects"], geometryGroup, webglobject );

					});

				}

			} else if ( object is Ribbon ||
						object is Line ||
						object is ParticleSystem ) {

				addBuffer( scene["__webglObjects"],  geometry, webglobject );

			} else if ( object is ImmediateRenderObject || (object["immediateRenderCallback"] != null) ) {

				addBufferImmediate( scene["__webglObjectsImmediate"], webglobject );

			} else if ( object is Sprite ) {

				scene["__webglSprites"].add( object );

			} else if ( object is LensFlare ) {

				scene["__webglFlares"].add( object );

			}

			object["__webglActive"] = true;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="addPostPlugin">
<span class="show-code">Code</span>
<strong>addPostPlugin</strong>(plugin) <a class="anchor-link" href="#addPostPlugin"
              title="Permalink to WebGLRenderer.addPostPlugin">#</a></h4>
<div class="doc">

<pre class="source">
addPostPlugin( plugin ) {
		plugin.init( this );
		renderPluginsPost.add( plugin );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="addPrePlugin">
<span class="show-code">Code</span>
<strong>addPrePlugin</strong>(plugin) <a class="anchor-link" href="#addPrePlugin"
              title="Permalink to WebGLRenderer.addPrePlugin">#</a></h4>
<div class="doc">

<pre class="source">
addPrePlugin( plugin ) {
		plugin.init( this );
		renderPluginsPre.add( plugin );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="allocateBones">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/int.html">int</a> <strong>allocateBones</strong>(<a href="../ThreeD/Object3D.html">Object3D</a> object) <a class="anchor-link" href="#allocateBones"
              title="Permalink to WebGLRenderer.allocateBones">#</a></h4>
<div class="doc">

<pre class="source">
int allocateBones ( Object3D object ) {

		if ( supportsBoneTextures &amp;&amp; (object != null) &amp;&amp; (object is SkinnedMesh) &amp;&amp; (object as SkinnedMesh).useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			int nVertexUniforms = _gl.getParameter( WebGLRenderingContext.MAX_VERTEX_UNIFORM_VECTORS );
			int nVertexMatrices = ( ( nVertexUniforms - 20 ) / 4 ).floor().toInt();

			var maxBones = nVertexMatrices;

			if ( object != null &amp;&amp; object is SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones &lt; object.bones.length ) {

					print( "WebGLRenderer: too many bones - ${object.bones.length} , this GPU supports just $maxBones  (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="allocateLights">
<span class="show-code">Code</span>
<strong>allocateLights</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../ThreeD/Light.html">Light</a>&gt; lights) <a class="anchor-link" href="#allocateLights"
              title="Permalink to WebGLRenderer.allocateLights">#</a></h4>
<div class="doc">

<pre class="source">
allocateLights ( List&lt;Light&gt; lights ) {

		var l, ll, light, dirLights, pointLights, spotLights, maxDirLights, maxPointLights, maxSpotLights;

		dirLights = pointLights = spotLights = maxDirLights = maxPointLights = maxSpotLights = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l ++ ) {

			light = lights[ l ];

			if ( (( light is DirectionalLight ) || ( light is SpotLight )) &amp;&amp;
			    (light as Dynamic).onlyShadow ) continue;

			if ( light is DirectionalLight ) dirLights ++;
			if ( light is PointLight ) pointLights ++;
			if ( light is SpotLight ) spotLights ++;

		}

		if ( ( pointLights + spotLights + dirLights ) &lt;= maxLights ) {

			maxDirLights = dirLights;
			maxPointLights = pointLights;
			maxSpotLights = spotLights;

		} else {

			maxDirLights = ( maxLights * dirLights / ( pointLights + dirLights ) ).ceil();
			maxPointLights = maxLights - maxDirLights;
			maxSpotLights = maxPointLights; // this is not really correct

		}

		return { 'directional' : maxDirLights, 'point' : maxPointLights, 'spot': maxSpotLights };

	}
</pre>
</div>
</div>
<div class="method"><h4 id="allocateShadows">
<span class="show-code">Code</span>
<strong>allocateShadows</strong>(lights) <a class="anchor-link" href="#allocateShadows"
              title="Permalink to WebGLRenderer.allocateShadows">#</a></h4>
<div class="doc">

<pre class="source">
allocateShadows ( lights ) {

		var l, ll, light, maxShadows = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l++ ) {

			light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light is SpotLight ) maxShadows ++;
			if ( light is DirectionalLight &amp;&amp; ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="areCustomAttributesDirty">
<span class="show-code">Code</span>
<strong>areCustomAttributesDirty</strong>(material) <a class="anchor-link" href="#areCustomAttributesDirty"
              title="Permalink to WebGLRenderer.areCustomAttributesDirty">#</a></h4>
<div class="doc">

<pre class="source">
areCustomAttributesDirty ( material ) {

		for ( var m in material.attributes ) {

			if ( m.needsUpdate ) return true;

		}

		return false;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="bufferGuessNormalType">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/int.html">int</a> <strong>bufferGuessNormalType</strong>(<a href="../ThreeD/WebGLMaterial.html">WebGLMaterial</a> material) <a class="anchor-link" href="#bufferGuessNormalType"
              title="Permalink to WebGLRenderer.bufferGuessNormalType">#</a></h4>
<div class="doc">

<pre class="source">
int bufferGuessNormalType ( WebGLMaterial material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( !material.needsNormals  ) {
			return Three.NoShading;
		}

		if ( material.needsSmoothNormals ) {

			return Three.SmoothShading;

		} else {

			return Three.FlatShading;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="bufferGuessUVType">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>bufferGuessUVType</strong>(material) <a class="anchor-link" href="#bufferGuessUVType"
              title="Permalink to WebGLRenderer.bufferGuessUVType">#</a></h4>
<div class="doc">

<pre class="source">
bool bufferGuessUVType ( material ) {

		// material must use some texture to require uvs

		if ((material.map != null) || 
		    (material.lightMap != null) || 
		    (material.bumpMap != null) || 
		    (material.specularMap != null) || 
		    (material.isShaderMaterial)) {

			return true;

		}

		return false;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="bufferGuessVertexColorType">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>bufferGuessVertexColorType</strong>(material) <a class="anchor-link" href="#bufferGuessVertexColorType"
              title="Permalink to WebGLRenderer.bufferGuessVertexColorType">#</a></h4>
<div class="doc">

<pre class="source">
bool bufferGuessVertexColorType ( material ) {

		if ( (material.vertexColors != null) &amp;&amp;  (material.vertexColors != Three.NoColors) ) {

			return material.vertexColors;

		}

		return false;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="buildProgram">
<span class="show-code">Code</span>
<a href="../ThreeD/Program.html">Program</a> <strong>buildProgram</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> shaderID, <a href="http://api.dartlang.org/dart_core/String.html">String</a> fragmentShader, <a href="http://api.dartlang.org/dart_core/String.html">String</a> vertexShader, uniforms, attributes, [<a href="http://api.dartlang.org/dart_core/int.html">int</a> maxDirLights = 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxPointLights = 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxSpotLights = 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxShadows = 0, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxBones = 0, <a href="../ThreeD/Texture.html">Texture</a> map = null, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> envMap = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> lightMap = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> bumpMap = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> specularMap = false, <a href="http://api.dartlang.org/dart_core/int.html">int</a> vertexColors = Three.NoColors, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> skinning = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> useVertexTexture = false, <a href="http://api.dartlang.org/dart_core/num.html">num</a> boneTextureWidth = null, <a href="http://api.dartlang.org/dart_core/num.html">num</a> boneTextureHeight = null, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> morphTargets = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> morphNormals = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> perPixel = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> wrapAround = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> doubleSided = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> shadowMapEnabled = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> shadowMapSoft = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> shadowMapDebug = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> shadowMapCascade = false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> sizeAttenuation = false, <a href="../ThreeD/Fog.html">Fog</a> fog = null, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> useFog = false, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxMorphTargets = 8, <a href="http://api.dartlang.org/dart_core/int.html">int</a> maxMorphNormals = 4, <a href="http://api.dartlang.org/dart_core/int.html">int</a> alphaTest = 0, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> metal = false]) <a class="anchor-link" href="#buildProgram"
              title="Permalink to WebGLRenderer.buildProgram">#</a></h4>
<div class="doc">

<pre class="source">
Program buildProgram( String shaderID, String fragmentShader, String vertexShader, uniforms, attributes,
				[	int maxDirLights = 0,
					int maxPointLights = 0,
					int maxSpotLights = 0,
					int maxShadows = 0,
					int maxBones = 0,
					Texture map = null,
					bool envMap = false,
					bool lightMap = false,
					bool bumpMap = false,
					bool specularMap = false,
					int vertexColors = Three.NoColors,
					bool skinning = false,
					bool useVertexTexture = false,
					num boneTextureWidth = null,
					num boneTextureHeight = null,
					bool morphTargets = false,
					bool morphNormals = false,
					bool perPixel = false,
					bool wrapAround = false,
					bool doubleSided = false,
					bool shadowMapEnabled = false,
					bool shadowMapSoft = false,
					bool shadowMapDebug = false,
					bool shadowMapCascade = false,
					bool sizeAttenuation = false,
					Fog fog = null,
		      bool useFog = false,
		      int maxMorphTargets = 8,
		      int maxMorphNormals = 4,
		      int alphaTest = 0,
		      bool metal = false] ) {

		var p, pl, glprogram, code;
		var chunks = [];

		// Generate code

		if ( shaderID != null ) {

			chunks.add( shaderID );

		} else {

			chunks.add( fragmentShader );
			chunks.add( vertexShader );

		}

		code =  "maxDirLights$maxDirLights"
		        "maxPointLights$maxPointLights"
		        "maxSpotLights$maxSpotLights"
		        "maxShadows$maxShadows"
		        "maxBones$maxBones"
		        "map$map"
		        "envMap$envMap"
		        "lightMap$lightMap"
		        "bumpMap$bumpMap"
		        "specularMap$specularMap"
		        "vertexColors$vertexColors"
		        "skinning$skinning"
		        "useVertexTexture$useVertexTexture"
		        "boneTextureWidth$boneTextureWidth"
		        "boneTextureHeight$boneTextureHeight"
		        "morphTargets$morphTargets"
           "morphNormals$morphNormals"
           "perPixel$perPixel"
           "wrapAround$wrapAround"
		        "doubleSided$doubleSided"
           "shadowMapEnabled$shadowMapEnabled"
           "shadowMapSoft$shadowMapSoft"
           "shadowMapDebug$shadowMapDebug"
		        "shadowMapCascade$shadowMapCascade"
           "sizeAttenuation$sizeAttenuation";


		// Check if code has been already compiled

		pl = _programs.length;
		for ( p = 0; p &lt; pl; p ++ ) {

			Program program = _programs[ p ];

			if ( program.code === code ) {

				// console.log( "Code already compiled." /*: \n\n" + code*/ );

			  program.usedTimes ++;

				return program;

			}

		}

		//console.log( "building new program " );

		//

		glprogram = _gl.createProgram();

		var prefix_vertex = Strings.join([

			"precision $precision float;",

			supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			gammaInput ? "#define GAMMA_INPUT" : "",
			gammaOutput ? "#define GAMMA_OUTPUT" : "",
			physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			"#define MAX_DIR_LIGHTS $maxDirLights",
			"#define MAX_POINT_LIGHTS $maxPointLights",
			"#define MAX_SPOT_LIGHTS $maxSpotLights",

			"#define MAX_SHADOWS $maxShadows",

			"#define MAX_BONES $maxBones",

			(map != null) ? "#define USE_MAP" : "",
			(envMap != null) ? "#define USE_ENVMAP" : "",
			(lightMap != null) ? "#define USE_LIGHTMAP" : "",
			(bumpMap != null) ? "#define USE_BUMPMAP" : "",
			(specularMap != null) ? "#define USE_SPECULARMAP" : "",
			(vertexColors != Three.NoColors) ? "#define USE_COLOR" : "",

			skinning ? "#define USE_SKINNING" : "",
			useVertexTexture ? "#define BONE_TEXTURE" : "",
			(boneTextureWidth != null) ? "#define N_BONE_PIXEL_X ${boneTextureWidth.toStringAsFixed(1)}" : "",
			(boneTextureHeight != null) ? "#define N_BONE_PIXEL_Y ${boneTextureHeight.toStringAsFixed( 1 )}" : "",

			morphTargets ? "#define USE_MORPHTARGETS" : "",
			morphNormals ? "#define USE_MORPHNORMALS" : "",
			perPixel ? "#define PHONG_PER_PIXEL" : "",
			wrapAround ? "#define WRAP_AROUND" : "",
			doubleSided ? "#define DOUBLE_SIDED" : "",

			shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			shadowMapSoft ? "#define SHADOWMAP_SOFT" : "",
			shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinVertexA;",
				"attribute vec4 skinVertexB;",
				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		],"\n");

		var prefix_fragment = Strings.join([

			"precision $precision float;",

			(bumpMap != null) ? "#extension GL_OES_standard_derivatives : enable" : "",

			"#define MAX_DIR_LIGHTS $maxDirLights",
			"#define MAX_POINT_LIGHTS $maxPointLights",
			"#define MAX_SPOT_LIGHTS $maxSpotLights",

			"#define MAX_SHADOWS $maxShadows",

			(alphaTest != 0) ? "#define ALPHATEST $alphaTest": "",

			gammaInput ? "#define GAMMA_INPUT" : "",
			gammaOutput ? "#define GAMMA_OUTPUT" : "",
			physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			( useFog &amp;&amp; (fog != null) ) ? "#define USE_FOG" : "",
			( useFog &amp;&amp; (fog is FogExp2) ) ? "#define FOG_EXP2" : "",

			(map != null) ? "#define USE_MAP" : "",
			(envMap != null) ? "#define USE_ENVMAP" : "",
			(lightMap != null) ? "#define USE_LIGHTMAP" : "",
			(bumpMap != null) ? "#define USE_BUMPMAP" : "",
			(specularMap != null) ? "#define USE_SPECULARMAP" : "",
			(vertexColors != Three.NoColors) ? "#define USE_COLOR" : "",

			metal ? "#define METAL" : "",
			perPixel ? "#define PHONG_PER_PIXEL" : "",
			wrapAround ? "#define WRAP_AROUND" : "",
			doubleSided ? "#define DOUBLE_SIDED" : "",

			shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			shadowMapSoft ? "#define SHADOWMAP_SOFT" : "",
			shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		], "\n");

		var glFragmentShader = getShader( "fragment", "$prefix_fragment$fragmentShader" );
		var glVertexShader = getShader( "vertex", "$prefix_vertex$vertexShader" );

		_gl.attachShader( glprogram, glVertexShader );
		_gl.attachShader( glprogram, glFragmentShader );

		_gl.linkProgram( glprogram );

		if ( !_gl.getProgramParameter( glprogram, WebGLRenderingContext.LINK_STATUS ) ) {

		  var status = _gl.getProgramParameter( glprogram, WebGLRenderingContext.VALIDATE_STATUS );
		  var error = _gl.getError();
			print( "Could not initialise shader\nVALIDATE_STATUS: $status, gl error [$error]" );

		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		//console.log( prefix_fragment + fragmentShader );
		//console.log( prefix_vertex + vertexShader );

		//program.uniforms = {};
		//program.attributes = {};

		var program = new Program( _programs_counter++,  glprogram, code, usedTimes: 1 );

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( useVertexTexture ) {

			identifiers.add( 'boneTexture' );

		} else {

			identifiers.add( 'boneGlobalMatrices' );

		}

		uniforms.forEach((u, _) =&gt; identifiers.add( u ));

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinVertexA", "skinVertexB", "skinIndex", "skinWeight"

		];

		for ( i = 0; i &lt; maxMorphTargets; i ++ ) {

			identifiers.add( "morphTarget$i" );

		}

		for ( i = 0; i &lt; maxMorphNormals; i ++ ) {

			identifiers.add( "morphNormal$i" );

		}

		if (attributes != null)
		  attributes.forEach((a, _) =&gt; identifiers.add( a ));

		cacheAttributeLocations( program, identifiers );

		_programs.add( program );

		info.memory.programs = _programs.length;

		return program;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="cacheAttributeLocations">
<span class="show-code">Code</span>
<strong>cacheAttributeLocations</strong>(program, identifiers) <a class="anchor-link" href="#cacheAttributeLocations"
              title="Permalink to WebGLRenderer.cacheAttributeLocations">#</a></h4>
<div class="doc">

<pre class="source">
cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		l = identifiers.length;
		for( i = 0; i &lt; l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program.glProgram, id );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="cacheUniformLocations">
<span class="show-code">Code</span>
<strong>cacheUniformLocations</strong>(program, identifiers) <a class="anchor-link" href="#cacheUniformLocations"
              title="Permalink to WebGLRenderer.cacheUniformLocations">#</a></h4>
<div class="doc">

<pre class="source">
cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		l = identifiers.length;
		for( i = 0; i &lt; l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program.glProgram, id );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="clampToMaxSize">
<span class="show-code">Code</span>
<strong>clampToMaxSize</strong>(image, maxSize) <a class="anchor-link" href="#clampToMaxSize"
              title="Permalink to WebGLRenderer.clampToMaxSize">#</a></h4>
<div class="doc">

<pre class="source">
clampToMaxSize ( image, maxSize ) {

		if ( image.width &lt;= maxSize &amp;&amp; image.height &lt;= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = ( image.width * maxSize / maxDimension ).floor();
		var newHeight = ( image.height * maxSize / maxDimension ).floor();

		var canvas = new CanvasElement();
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.context2d;
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="clear">
<span class="show-code">Code</span>
<strong>clear</strong>([<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> color = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> depth = true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> stencil = true]) <a class="anchor-link" href="#clear"
              title="Permalink to WebGLRenderer.clear">#</a></h4>
<div class="doc">

<pre class="source">
clear( [ bool color = true, bool depth = true, bool stencil = true] ) {

		var bits = 0;

		if ( color ) bits |= WebGLRenderingContext.COLOR_BUFFER_BIT;
		if ( depth ) bits |= WebGLRenderingContext.DEPTH_BUFFER_BIT;
		if ( stencil ) bits |= WebGLRenderingContext.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="clearCustomAttributes">
<span class="show-code">Code</span>
<strong>clearCustomAttributes</strong>(material) <a class="anchor-link" href="#clearCustomAttributes"
              title="Permalink to WebGLRenderer.clearCustomAttributes">#</a></h4>
<div class="doc">

<pre class="source">
clearCustomAttributes ( material ) {

		for ( var m in material.attributes ) {

			m.needsUpdate = false;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="clearTarget">
<span class="show-code">Code</span>
<strong>clearTarget</strong>(renderTarget, color, depth, stencil) <a class="anchor-link" href="#clearTarget"
              title="Permalink to WebGLRenderer.clearTarget">#</a></h4>
<div class="doc">

<pre class="source">
clearTarget( renderTarget, color, depth, stencil ) {
		setRenderTarget( renderTarget );
		clear( color, depth, stencil );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="context">
<span class="show-code">Code</span>
<strong>get context</strong>() <a class="anchor-link" href="#context"
              title="Permalink to WebGLRenderer.get context">#</a></h4>
<div class="doc">

<pre class="source">
get context =&gt; _gl;
</pre>
</div>
</div>
<div class="method"><h4 id="createLineBuffers">
<span class="show-code">Code</span>
<strong>createLineBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#createLineBuffers"
              title="Permalink to WebGLRenderer.createLineBuffers">#</a></h4>
<div class="doc">

<pre class="source">
createLineBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		info.memory.geometries ++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="createMeshBuffers">
<span class="show-code">Code</span>
<strong>createMeshBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometryGroup) <a class="anchor-link" href="#createMeshBuffers"
              title="Permalink to WebGLRenderer.createMeshBuffers">#</a></h4>
<div class="doc">

<pre class="source">
createMeshBuffers ( WebGLGeometry geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinVertexABuffer = _gl.createBuffer();
		geometryGroup.__webglSkinVertexBBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets != null ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			 ml = geometryGroup.numMorphTargets;

			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.add( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals != null ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			ml = geometryGroup.numMorphNormals;

			for ( m = 0; m &lt; ml; m ++ ) {
				geometryGroup.__webglMorphNormalsBuffers.add( _gl.createBuffer() );

			}

		}

		info.memory.geometries++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="createParticleBuffers">
<span class="show-code">Code</span>
<strong>createParticleBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#createParticleBuffers"
              title="Permalink to WebGLRenderer.createParticleBuffers">#</a></h4>
<div class="doc">

<pre class="source">
createParticleBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		info.memory.geometries++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="createRibbonBuffers">
<span class="show-code">Code</span>
<strong>createRibbonBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#createRibbonBuffers"
              title="Permalink to WebGLRenderer.createRibbonBuffers">#</a></h4>
<div class="doc">

<pre class="source">
createRibbonBuffers ( WebGLGeometry geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		info.memory.geometries ++;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateMaterial">
<span class="show-code">Code</span>
<strong>deallocateMaterial</strong>(material) <a class="anchor-link" href="#deallocateMaterial"
              title="Permalink to WebGLRenderer.deallocateMaterial">#</a></h4>
<div class="doc">

<pre class="source">
deallocateMaterial( material ) {

		Program program = material.program;
   
		if ( program == null ) return;

		material.program = null;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		program.usedTimes --;

   var deleteProgram = ( program.usedTimes == 0 );

		if ( deleteProgram ) {

			// -avoid using array.splice, this is costlier than creating new array from scratch

			_programs.removeRange(_programs.indexOf(program), 1);

			_gl.deleteProgram( program.glProgram );

			info.memory.programs --;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateObject">
<span class="show-code">Code</span>
<strong>deallocateObject</strong>(<a href="../ThreeD/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#deallocateObject"
              title="Permalink to WebGLRenderer.deallocateObject">#</a></h4>
<div class="doc">

<pre class="source">
deallocateObject( WebGLObject webglobject ) {

	  Object3D object = webglobject.object; // unwrap
	  
		if ( ! webglobject.__webglInit ) return;

		webglobject.__webglInit = false;

		webglobject._modelViewMatrix = null; //delete object["_modelViewMatrix"];
		webglobject._normalMatrix = null; //delete object["_normalMatrix"];

		webglobject._normalMatrixArray = null; //delete object["_normalMatrixArray"];
		webglobject._modelViewMatrixArray = null; //delete object["_modelViewMatrixArray"];
		webglobject.modelMatrixArray = null;//delete object["modelMatrixArray"];

		WebGLGeometry geometry = webglobject.webglgeometry;
		
		if ( object is Mesh ) {
 
			for ( var g in geometry.geometryGroups ) {

				deleteMeshBuffers( geometry.geometryGroups[ g ] );

			}

		} else if ( object is Ribbon ) {

			deleteRibbonBuffers( geometry);

		} else if ( object is Line ) {

			deleteLineBuffers( geometry );

		} else if ( object is ParticleSystem ) {

			deleteParticleBuffers( geometry );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateRenderTarget">
<span class="show-code">Code</span>
<strong>deallocateRenderTarget</strong>(<a href="../ThreeD/WebGLRenderTarget.html">WebGLRenderTarget</a> renderTarget) <a class="anchor-link" href="#deallocateRenderTarget"
              title="Permalink to WebGLRenderer.deallocateRenderTarget">#</a></h4>
<div class="doc">

<pre class="source">
deallocateRenderTarget( WebGLRenderTarget renderTarget ) {

		if ( (renderTarget == null) || (renderTarget.__webglTexture == null) ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget is WebGLRenderTargetCube ) {

			for ( var i = 0; i &lt; 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deallocateTexture">
<span class="show-code">Code</span>
<strong>deallocateTexture</strong>(texture) <a class="anchor-link" href="#deallocateTexture"
              title="Permalink to WebGLRenderer.deallocateTexture">#</a></h4>
<div class="doc">

<pre class="source">
deallocateTexture( Dynamic texture ) {

		if ( ! texture["__webglInit"] ) return;

		texture["__webglInit"] = false;
		_gl.deleteTexture( texture["__webglTexture"] );

		info.memory.textures --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deleteLineBuffers">
<span class="show-code">Code</span>
<strong>deleteLineBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#deleteLineBuffers"
              title="Permalink to WebGLRenderer.deleteLineBuffers">#</a></h4>
<div class="doc">

<pre class="source">
deleteLineBuffers ( WebGLGeometry geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );

		info.memory.geometries --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deleteMeshBuffers">
<span class="show-code">Code</span>
<strong>deleteMeshBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometryGroup) <a class="anchor-link" href="#deleteMeshBuffers"
              title="Permalink to WebGLRenderer.deleteMeshBuffers">#</a></h4>
<div class="doc">

<pre class="source">
deleteMeshBuffers ( WebGLGeometry geometryGroup ) {

		_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );
		_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );
		_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );
		_gl.deleteBuffer( geometryGroup.__webglColorBuffer );
		_gl.deleteBuffer( geometryGroup.__webglUVBuffer );
		_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );

		_gl.deleteBuffer( geometryGroup.__webglSkinVertexABuffer );
		_gl.deleteBuffer( geometryGroup.__webglSkinVertexBBuffer );
		_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );
		_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );

		_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );
		_gl.deleteBuffer( geometryGroup.__webglLineBuffer );

		var m, ml;

		if ( geometryGroup.numMorphTargets != null ) {

			ml = geometryGroup.numMorphTargets;

			for ( m = 0; m &lt; ml; m ++ ) {

				_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

			}

		}

		if ( geometryGroup.numMorphNormals &gt; 0 ) {

			ml = geometryGroup.numMorphNormals;

			for ( m = 0; m &lt; ml; m ++ ) {

				_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

			}

		}


		if ( geometryGroup.__webglCustomAttributesList ) {

			for ( var id in geometryGroup.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometryGroup.__webglCustomAttributesList[ id ].buffer );

			}

		}

		info.memory.geometries --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deleteParticleBuffers">
<span class="show-code">Code</span>
<strong>deleteParticleBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#deleteParticleBuffers"
              title="Permalink to WebGLRenderer.deleteParticleBuffers">#</a></h4>
<div class="doc">

<pre class="source">
deleteParticleBuffers ( WebGLGeometry geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );

		info.memory.geometries --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="deleteRibbonBuffers">
<span class="show-code">Code</span>
<strong>deleteRibbonBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#deleteRibbonBuffers"
              title="Permalink to WebGLRenderer.deleteRibbonBuffers">#</a></h4>
<div class="doc">

<pre class="source">
deleteRibbonBuffers ( WebGLGeometry geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );

		info.memory.geometries --;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="domElement">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_html/Element.html">Element</a> <strong>get domElement</strong>() <a class="anchor-link" href="#domElement"
              title="Permalink to WebGLRenderer.get domElement">#</a></h4>
<div class="doc">

<pre class="source">
Element get domElement =&gt; canvas;
</pre>
</div>
</div>
<div class="method"><h4 id="enableScissorTest">
<span class="show-code">Code</span>
<strong>enableScissorTest</strong>(enable) <a class="anchor-link" href="#enableScissorTest"
              title="Permalink to WebGLRenderer.enableScissorTest">#</a></h4>
<div class="doc">

<pre class="source">
enableScissorTest( enable ) {
		enable ? _gl.enable( WebGLRenderingContext.SCISSOR_TEST ) : _gl.disable( WebGLRenderingContext.SCISSOR_TEST );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="filterFallback">
<span class="show-code">Code</span>
<strong>filterFallback</strong>(f) <a class="anchor-link" href="#filterFallback"
              title="Permalink to WebGLRenderer.filterFallback">#</a></h4>
<div class="doc">

<pre class="source">
filterFallback ( f ) {

		if ( f === Three.NearestFilter || f === Three.NearestMipMapNearestFilter || f === Three.NearestMipMapLinearFilter ) {

			return WebGLRenderingContext.NEAREST;

		}

		return WebGLRenderingContext.LINEAR;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="getBufferMaterial">
<span class="show-code">Code</span>
<a href="../ThreeD/WebGLMaterial.html">WebGLMaterial</a> <strong>getBufferMaterial</strong>(<a href="../ThreeD/WebGLObject.html">WebGLObject</a> object, <a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometryGroup) <a class="anchor-link" href="#getBufferMaterial"
              title="Permalink to WebGLRenderer.getBufferMaterial">#</a></h4>
<div class="doc">

<pre class="source">
WebGLMaterial getBufferMaterial( WebGLObject object, WebGLGeometry geometryGroup ) {

	  Material material;
	  
		if ( (object.material != null) &amp;&amp; ! ( object.material is MeshFaceMaterial ) ) {

			material = object.material;

		} else if ( geometryGroup.materialIndex &gt;= 0 ) {

			material = object.geometry.materials[ geometryGroup.materialIndex ];

		}

		return new WebGLMaterial.from(material);
	}
</pre>
</div>
</div>
<div class="method"><h4 id="getShader">
<span class="show-code">Code</span>
<strong>getShader</strong>(type, string) <a class="anchor-link" href="#getShader"
              title="Permalink to WebGLRenderer.getShader">#</a></h4>
<div class="doc">

<pre class="source">
getShader ( type, string ) {

		var shader;

		if ( type === "fragment" ) {

			shader = _gl.createShader( WebGLRenderingContext.FRAGMENT_SHADER );

		} else if ( type === "vertex" ) {

			shader = _gl.createShader( WebGLRenderingContext.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, WebGLRenderingContext.COMPILE_STATUS ) ) {

			print( _gl.getShaderInfoLog( shader ) );
			print( addLineNumbers( string ) );
			return null;

		}

		return shader;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initCustomAttributes">
<span class="show-code">Code</span>
<strong>initCustomAttributes</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initCustomAttributes"
              title="Permalink to WebGLRenderer.initCustomAttributes">#</a></h4>
<div class="doc">

<pre class="source">
initCustomAttributes ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		var material = object.webglmaterial;

		if ( material.attributes != null ) {

			if ( geometry.__webglCustomAttributesList == null ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if( !attribute["__webglInitialized"] || attribute.createUniqueBuffers ) {

					attribute["__webglInitialized"] = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = new Buffer(_gl.createBuffer());
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.add( attribute );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initDirectBuffers">
<span class="show-code">Code</span>
<strong>initDirectBuffers</strong>(<a href="../ThreeD/BufferGeometry.html">BufferGeometry</a> geometry) <a class="anchor-link" href="#initDirectBuffers"
              title="Permalink to WebGLRenderer.initDirectBuffers">#</a></h4>
<div class="doc">

<pre class="source">
initDirectBuffers( BufferGeometry geometry ) {

		var a, attribute, type;

		geometry.attributes.forEach((a, v) {

			if ( a === "index" ) {

				type = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER;

			} else {

				type = WebGLRenderingContext.ARRAY_BUFFER;

			}

			attribute = v;

			attribute.buffer = _gl.createBuffer();

			_gl.bindBuffer( type, attribute.buffer );
			_gl.bufferData( type, attribute.array, WebGLRenderingContext.STATIC_DRAW );

		});

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initGL">
<span class="show-code">Code</span>
<strong>initGL</strong>() <a class="anchor-link" href="#initGL"
              title="Permalink to WebGLRenderer.initGL">#</a></h4>
<div class="doc">

<pre class="source">
initGL () {

		try {
			_gl = canvas.getContext( 'experimental-webgl'); //, { alpha: _alpha, premultipliedAlpha: _premultipliedAlpha, antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } )
			if ( _gl == null ) {

				throw 'Error creating WebGL context.';

			}
		} catch ( error ) {
		  
			print( error );

		}

		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' );
		if (_glExtensionTextureFilterAnisotropic == null)
		  _glExtensionTextureFilterAnisotropic = _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' );
		if (_glExtensionTextureFilterAnisotropic == null)
		  _glExtensionTextureFilterAnisotropic = _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );


		if ( _glExtensionTextureFloat == null ) {

			print( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( _glExtensionStandardDerivatives == null ) {

		  print( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( _glExtensionTextureFilterAnisotropic == null ) {

		  print( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initLineBuffers">
<span class="show-code">Code</span>
<strong>initLineBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initLineBuffers"
              title="Permalink to WebGLRenderer.initLineBuffers">#</a></h4>
<div class="doc">

<pre class="source">
initLineBuffers ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initMaterial">
<span class="show-code">Code</span>
<strong>initMaterial</strong>(<a href="../ThreeD/WebGLMaterial.html">WebGLMaterial</a> material, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../ThreeD/Light.html">Light</a>&gt; lights, <a href="../ThreeD/Fog.html">Fog</a> fog, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#initMaterial"
              title="Permalink to WebGLRenderer.initMaterial">#</a></h4>
<div class="doc">

<pre class="source">
initMaterial( WebGLMaterial material, List&lt;Light&gt; lights, Fog fog, WebGLObject webglobject ) {

	  Object3D object = webglobject.object;
	  
		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material.isMeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material.isMeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material.isMeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material.isMeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material.isMeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material.isLineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material.isParticleBasicMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID != null) {

			setMaterialShaders( material, ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		material.program = buildProgram( 
			shaderID, 
			material.fragmentShader, 
			material.vertexShader, 
			material.uniforms, 
			material.attributes, 
			map: material.map,
			envMap: material.envMap,
			lightMap: material.lightMap,
			bumpMap: material.bumpMap,
			specularMap: material.specularMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,

			sizeAttenuation: material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: supportsBoneTextures &amp;&amp; (object != null) &amp;&amp; (object is SkinnedMesh) &amp;&amp; (object as SkinnedMesh).useVertexTexture,
			boneTextureWidth: ((object != null) &amp;&amp; (object is SkinnedMesh)) ? (object as SkinnedMesh).boneTextureWidth : null,
			boneTextureHeight: ((object != null) &amp;&amp; (object is SkinnedMesh)) ? (object as SkinnedMesh).boneTextureHeight : null,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: maxMorphTargets,
			maxMorphNormals: maxMorphNormals,

			maxDirLights: maxLightCount['directional'],
			maxPointLights: maxLightCount['point'],
			maxSpotLights: maxLightCount['spot'],

			maxShadows: maxShadows,
			shadowMapEnabled: shadowMapEnabled &amp;&amp; object.receiveShadow,
			shadowMapSoft: shadowMapSoft,
			shadowMapDebug: shadowMapDebug,
			shadowMapCascade: shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			perPixel: material.perPixel,
			wrapAround: material.wrapAround,
			doubleSided: material.side === Three.DoubleSide );

		var attributes = material.program.attributes;

		if ( attributes["position"] &gt;= 0 ) _gl.enableVertexAttribArray( attributes["position"] );
		if ( attributes["color"] &gt;= 0 ) _gl.enableVertexAttribArray( attributes["color"] );
		if ( attributes["normal"] &gt;= 0 ) _gl.enableVertexAttribArray( attributes["normal"] );
		if ( attributes["tangent"] &gt;= 0 ) _gl.enableVertexAttribArray( attributes["tangent"] );

		if ( material.skinning &amp;&amp;
			 attributes["skinVertexA"] &gt;=0 &amp;&amp; attributes["skinVertexB"] &gt;= 0 &amp;&amp;
			 attributes["skinIndex"] &gt;= 0 &amp;&amp; attributes["skinWeight"] &gt;= 0 ) {

			_gl.enableVertexAttribArray( attributes["skinVertexA"] );
			_gl.enableVertexAttribArray( attributes["skinVertexB"] );
			_gl.enableVertexAttribArray( attributes["skinIndex"] );
			_gl.enableVertexAttribArray( attributes["skinWeight"] );

		}

		if ( material.attributes != null) {

			for ( a in material.attributes ) {

				if( attributes[ a ] != null &amp;&amp; attributes[ a ] &gt;= 0 ) _gl.enableVertexAttribArray( attributes[ a ] );

			}

		}

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i &lt; maxMorphTargets; i ++ ) {

				id = "$base$i";

				if ( attributes[ id ] &gt;= 0 ) {

					_gl.enableVertexAttribArray( attributes[ id ] );
					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i &lt; maxMorphNormals; i ++ ) {

				id = "$base$i";

				if ( attributes[ id ] &gt;= 0 ) {

					_gl.enableVertexAttribArray( attributes[ id ] );
					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		material.uniforms.forEach( (k, u) =&gt; material.uniformsList.add( [ u, k ] ));

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initMeshBuffers">
<span class="show-code">Code</span>
<strong>initMeshBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initMeshBuffers"
              title="Permalink to WebGLRenderer.initMeshBuffers">#</a></h4>
<div class="doc">

<pre class="source">
initMeshBuffers ( WebGLGeometry geometryGroup, WebGLObject object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,
			faces4 = geometryGroup.faces4,

			nvertices = faces3.length * 3 + faces4.length * 4,
			ntris     = faces3.length * 1 + faces4.length * 2,
			nlines    = faces3.length * 3 + faces4.length * 4;

		WebGLMaterial material = getBufferMaterial( object, geometryGroup );

		var uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		//console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType != Three.NoShading ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceUvs.length &gt; 0 || geometry.faceVertexUvs.length &gt; 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceUvs.length &gt; 1 || geometry.faceVertexUvs.length &gt; 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( !object.geometry.skinWeights.isEmpty() &amp;&amp; !object.geometry.skinIndices.isEmpty() ) {

			geometryGroup.__skinVertexAArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinVertexBArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
		geometryGroup.__lineArray = new Uint16Array( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets != null ) {

			geometryGroup.__morphTargetsArrays = [];

			ml = geometryGroup.numMorphTargets;
			    
			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.add( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals != null ) {

			geometryGroup.__morphNormalsArrays = [];

			ml = geometryGroup.numMorphNormals;
			    
			for ( m = 0; m &lt; ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.add( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes != null) {

			if ( geometryGroup.__webglCustomAttributesList == null ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			material.attributes.forEach((a) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if( ( attribute["__webglInitialized"] == null ||  attribute["__webglInitialized"] == false) || 
				    ( attribute["createUniqueBuffers"] != null &amp;&amp; attribute["createUniqueBuffers"]) ) {

					attribute["__webglInitialized"] = true;

					var size = 1;		// "f" and "i"

					if( attribute["type"] === "v2" ) size = 2;
					else if( attribute["type"] === "v3" ) size = 3;
					else if( attribute["type"] === "v4" ) size = 4;
					else if( attribute["type"] === "c"  ) size = 3;

					attribute["size"] = size;

					attribute["array"] = new Float32Array( nvertices * size );

					var buffer = new Buffer(_gl.createBuffer());
					buffer.belongsToAttribute = a;
					attribute["buffer"] = buffer;

					originalAttribute.needsUpdate = true;
					attribute["__original"] = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.add( attribute );

			});

		}

		geometryGroup.__inittedArrays = true;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initParticleBuffers">
<span class="show-code">Code</span>
<strong>initParticleBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#initParticleBuffers"
              title="Permalink to WebGLRenderer.initParticleBuffers">#</a></h4>
<div class="doc">

<pre class="source">
initParticleBuffers ( WebGLGeometry geometry, WebGLObject object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initRibbonBuffers">
<span class="show-code">Code</span>
<strong>initRibbonBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#initRibbonBuffers"
              title="Permalink to WebGLRenderer.initRibbonBuffers">#</a></h4>
<div class="doc">

<pre class="source">
initRibbonBuffers ( WebGLGeometry geometry ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__webglVertexCount = nvertices;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="initWebGLObjects">
<span class="show-code">Code</span>
<strong>initWebGLObjects</strong>(<a href="../ThreeD/Scene.html">Scene</a> scene) <a class="anchor-link" href="#initWebGLObjects"
              title="Permalink to WebGLRenderer.initWebGLObjects">#</a></h4>
<div class="doc">

<pre class="source">
initWebGLObjects( Scene scene ) {

		if ( scene["__webglObjects"] == null ) {

			scene["__webglObjects"] = [];
			scene["__webglObjectsImmediate"] = [];
			scene["__webglSprites"] = [];
			scene["__webglFlares"] = [];

		}

		while ( scene.__objectsAdded.length &gt; 0 ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.removeRange( 0, 1 );

		}

		while ( scene.__objectsRemoved.length &gt; 0) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.removeRange( 0, 1 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene["__webglObjects"].length; o &lt; ol; o ++ ) {

			updateObject( scene["__webglObjects"][ o ] );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="isPowerOfTwo">
<span class="show-code">Code</span>
<strong>isPowerOfTwo</strong>(value) <a class="anchor-link" href="#isPowerOfTwo"
              title="Permalink to WebGLRenderer.isPowerOfTwo">#</a></h4>
<div class="doc">

<pre class="source">
isPowerOfTwo ( value ) =&gt; ( value &amp; ( value - 1 ) ) === 0;
</pre>
</div>
</div>
<div class="method"><h4 id="loadUniformsGeneric">
<span class="show-code">Code</span>
<strong>loadUniformsGeneric</strong>(program, uniforms) <a class="anchor-link" href="#loadUniformsGeneric"
              title="Permalink to WebGLRenderer.loadUniformsGeneric">#</a></h4>
<div class="doc">

<pre class="source">
loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, i, il, j, jl, offset;

		jl = uniforms.length;
		for ( j = 0; j &lt; jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( location == null ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.value;

			if ( type === "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type === "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type === "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type === "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type === "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type === "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, (value is List) ? new Float32Array.fromList(value) : value );

			} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, (value is List) ? new Float32Array.fromList(value) : value );

			} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, (value is List) ? new Float32Array.fromList(value) : value );

			} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)
       
				_gl.uniform3fv( location, (value is List) ? new Float32Array.fromList(value) : value );

			} else if ( type === "v2v" ) { // array of THREE.Vector2

				if ( uniform._array == null ) {

					uniform._array = new Float32Array( 2 * value.length );

				}

				il = value.length;
				for ( i = 0; i &lt; il; i ++ ) {

					offset = i * 2;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;

				}

				_gl.uniform2fv( location, uniform._array );

			} else if ( type === "v3v" ) { // array of THREE.Vector3

				if ( uniform._array == null ) {

					uniform._array = new Float32Array( 3 * value.length );

				}

				il = value.length;
				for ( i = 0; i &lt; il; i ++ ) {

					offset = i * 3;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;

				}

				_gl.uniform3fv( location, uniform._array );

			} else if ( type === "v4v" ) { // array of THREE.Vector4

				if ( uniform._array == null ) {

					uniform._array = new Float32Array( 4 * value.length );

				}

				il = value.length;
				for ( i = 0; i &lt; il; i ++ ) {

					offset = i * 4;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;
					uniform._array[ offset + 3 ] = value[ i ].w;

				}

				_gl.uniform4fv( location, uniform._array );

			} else if ( type === "m4") { // single THREE.Matrix4

				if ( uniform._array == null ) {

					uniform._array = new Float32Array( 16 );

				}

				value.flattenToArray( uniform._array );
				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "m4v" ) { // array of THREE.Matrix4

				if ( uniform._array == null ) {

					uniform._array = new Float32Array( 16 * value.length );

				}

				il = value.length;
				for ( i = 0; i &lt; il; i ++ ) {

					value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

				}

				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "t" ) { // single THREE.Texture (2d or cube)

				_gl.uniform1i( location, value );

				texture = uniform.texture;

				if ( texture == null ) continue;

				if ( texture.image is List &amp;&amp; texture.image.length === 6 ) {

					setCubeTexture( texture, value );

				} else if ( texture is WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, value );

				} else {

					setTexture( texture, value );

				}

			} else if ( type === "tv" ) { // array of THREE.Texture (2d)

				if ( uniform._array == null ) {

					uniform._array = [];

					il = uniform.texture.length;
					for( i = 0; i &lt; il; i ++ ) {

						uniform._array[ i ] = value + i;

					}

				}

				_gl.uniform1iv( location, uniform._array );

				il = uniform.texture.length;
				for( i = 0; i &lt; il; i ++ ) {

					texture = uniform.texture[ i ];

					if ( !texture ) continue;

					setTexture( texture, uniform._array[ i ] );

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="loadUniformsMatrices">
<span class="show-code">Code</span>
<strong>loadUniformsMatrices</strong>(uniforms, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#loadUniformsMatrices"
              title="Permalink to WebGLRenderer.loadUniformsMatrices">#</a></h4>
<div class="doc">

<pre class="source">
loadUniformsMatrices ( uniforms, WebGLObject object ) {
	  
		_gl.uniformMatrix4fv( uniforms["modelViewMatrix"], false, object._modelViewMatrix.elements );

		if ( uniforms["normalMatrix"] != null ) {

			_gl.uniformMatrix3fv( uniforms["normalMatrix"], false, object._normalMatrix.elements );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="numericalSort">
<span class="show-code">Code</span>
<strong>numericalSort</strong>(a, b) <a class="anchor-link" href="#numericalSort"
              title="Permalink to WebGLRenderer.numericalSort">#</a></h4>
<div class="doc">

<pre class="source">
numericalSort ( a, b ) =&gt; (b[ 1 ] - a[ 1 ]).toInt();
</pre>
</div>
</div>
<div class="method"><h4 id="painterSort">
<span class="show-code">Code</span>
<strong>painterSort</strong>(a, b) <a class="anchor-link" href="#painterSort"
              title="Permalink to WebGLRenderer.painterSort">#</a></h4>
<div class="doc">

<pre class="source">
painterSort ( a, b ) =&gt; (b.z - a.z).toInt();
</pre>
</div>
</div>
<div class="method"><h4 id="paramThreeToGL">
<span class="show-code">Code</span>
<strong>paramThreeToGL</strong>(p) <a class="anchor-link" href="#paramThreeToGL"
              title="Permalink to WebGLRenderer.paramThreeToGL">#</a></h4>
<div class="doc">

<pre class="source">
paramThreeToGL ( p ) {

		if ( p === Three.RepeatWrapping ) return WebGLRenderingContext.REPEAT;
		if ( p === Three.ClampToEdgeWrapping ) return WebGLRenderingContext.CLAMP_TO_EDGE;
		if ( p === Three.MirroredRepeatWrapping ) return WebGLRenderingContext.MIRRORED_REPEAT;

		if ( p === Three.NearestFilter ) return WebGLRenderingContext.NEAREST;
		if ( p === Three.NearestMipMapNearestFilter ) return WebGLRenderingContext.NEAREST_MIPMAP_NEAREST;
		if ( p === Three.NearestMipMapLinearFilter ) return WebGLRenderingContext.NEAREST_MIPMAP_LINEAR;

		if ( p === Three.LinearFilter ) return WebGLRenderingContext.LINEAR;
		if ( p === Three.LinearMipMapNearestFilter ) return WebGLRenderingContext.LINEAR_MIPMAP_NEAREST;
		if ( p === Three.LinearMipMapLinearFilter ) return WebGLRenderingContext.LINEAR_MIPMAP_LINEAR;

		if ( p === Three.UnsignedByteType ) return WebGLRenderingContext.UNSIGNED_BYTE;
		if ( p === Three.UnsignedShort4444Type ) return WebGLRenderingContext.UNSIGNED_SHORT_4_4_4_4;
		if ( p === Three.UnsignedShort5551Type ) return WebGLRenderingContext.UNSIGNED_SHORT_5_5_5_1;
		if ( p === Three.UnsignedShort565Type ) return WebGLRenderingContext.UNSIGNED_SHORT_5_6_5;

		if ( p === Three.ByteType ) return WebGLRenderingContext.BYTE;
		if ( p === Three.ShortType ) return WebGLRenderingContext.SHORT;
		if ( p === Three.UnsignedShortType ) return WebGLRenderingContext.UNSIGNED_SHORT;
		if ( p === Three.IntType ) return WebGLRenderingContext.INT;
		if ( p === Three.UnsignedIntType ) return WebGLRenderingContext.UNSIGNED_INT;
		if ( p === Three.FloatType ) return WebGLRenderingContext.FLOAT;

		if ( p === Three.AlphaFormat ) return WebGLRenderingContext.ALPHA;
		if ( p === Three.RGBFormat ) return WebGLRenderingContext.RGB;
		if ( p === Three.RGBAFormat ) return WebGLRenderingContext.RGBA;
		if ( p === Three.LuminanceFormat ) return WebGLRenderingContext.LUMINANCE;
		if ( p === Three.LuminanceAlphaFormat ) return WebGLRenderingContext.LUMINANCE_ALPHA;

		if ( p === Three.AddEquation ) return WebGLRenderingContext.FUNC_ADD;
		if ( p === Three.SubtractEquation ) return WebGLRenderingContext.FUNC_SUBTRACT;
		if ( p === Three.ReverseSubtractEquation ) return WebGLRenderingContext.FUNC_REVERSE_SUBTRACT;

		if ( p === Three.ZeroFactor ) return WebGLRenderingContext.ZERO;
		if ( p === Three.OneFactor ) return WebGLRenderingContext.ONE;
		if ( p === Three.SrcColorFactor ) return WebGLRenderingContext.SRC_COLOR;
		if ( p === Three.OneMinusSrcColorFactor ) return WebGLRenderingContext.ONE_MINUS_SRC_COLOR;
		if ( p === Three.SrcAlphaFactor ) return WebGLRenderingContext.SRC_ALPHA;
		if ( p === Three.OneMinusSrcAlphaFactor ) return WebGLRenderingContext.ONE_MINUS_SRC_ALPHA;
		if ( p === Three.DstAlphaFactor ) return WebGLRenderingContext.DST_ALPHA;
		if ( p === Three.OneMinusDstAlphaFactor ) return WebGLRenderingContext.ONE_MINUS_DST_ALPHA;

		if ( p === Three.DstColorFactor ) return WebGLRenderingContext.DST_COLOR;
		if ( p === Three.OneMinusDstColorFactor ) return WebGLRenderingContext.ONE_MINUS_DST_COLOR;
		if ( p === Three.SrcAlphaSaturateFactor ) return WebGLRenderingContext.SRC_ALPHA_SATURATE;

		print("[paramThreeToGL] Unknown param $p");
		return 0;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsCommon">
<span class="show-code">Code</span>
<strong>refreshUniformsCommon</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsCommon"
              title="Permalink to WebGLRenderer.refreshUniformsCommon">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsCommon ( uniforms, material ) {

		uniforms["opacity"].value = material.opacity;

		if ( gammaInput ) {

			uniforms["diffuse"].value.copyGammaToLinear( material.color );

		} else {

			uniforms["diffuse"].value = material.color;

		}

		uniforms["map"].texture = material.map;
		uniforms["lightMap"].texture = material.lightMap;
		uniforms["specularMap"].texture = material.specularMap;

		if ( material.bumpMap != null ) {

			uniforms["bumpMap"].texture = material.bumpMap;
			uniforms["bumpScale"].value = material.bumpScale;

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. bump map

		var uvScaleMap;

		if ( material.map != null ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap != null ) {

			uvScaleMap = material.specularMap;

		} else if ( material.bumpMap != null ) {

			uvScaleMap = material.bumpMap;

		}

		if ( uvScaleMap != null ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms["offsetRepeat"].value.setValues( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms["envMap"].texture = material.envMap;
		uniforms["flipEnvMap"].value = ( material.envMap is WebGLRenderTargetCube ) ? 1 : -1;

		if ( gammaInput ) {

			//uniforms["reflectivity"].value = material.reflectivity * material.reflectivity;
			uniforms["reflectivity"].value = material.reflectivity;

		} else {

			uniforms["reflectivity"].value = material.reflectivity;

		}

		uniforms["refractionRatio"].value = material.refractionRatio;
		uniforms["combine"].value = material.combine;
		uniforms["useRefract"].value = (material.envMap != null) &amp;&amp; (material.envMap.mapping is CubeRefractionMapping);

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsFog">
<span class="show-code">Code</span>
<strong>refreshUniformsFog</strong>(uniforms, <a href="../ThreeD/Fog.html">Fog</a> fog) <a class="anchor-link" href="#refreshUniformsFog"
              title="Permalink to WebGLRenderer.refreshUniformsFog">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsFog ( uniforms, Fog fog ) {

		uniforms["fogColor"].value = fog.color;

		if ( fog is FogLinear ) {

			uniforms["fogNear"].value = fog.near;
			uniforms["fogFar"].value = fog.far;

		} else if ( fog is FogExp2 ) {

			uniforms["fogDensity"].value = fog.density;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsLambert">
<span class="show-code">Code</span>
<strong>refreshUniformsLambert</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsLambert"
              title="Permalink to WebGLRenderer.refreshUniformsLambert">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsLambert ( uniforms, material ) {

		if ( gammaInput ) {

			uniforms["ambient"].value.copyGammaToLinear( material.ambient );
			uniforms["emissive"].value.copyGammaToLinear( material.emissive );

		} else {

			uniforms["ambient"].value = material.ambient;
			uniforms["emissive"].value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms["wrapRGB"].value.copy( material.wrapRGB );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsLights">
<span class="show-code">Code</span>
<strong>refreshUniformsLights</strong>(<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="../ThreeD/Uniform.html">Uniform</a>&gt; uniforms, <a href="http://api.dartlang.org/dart_core/Map.html">Map</a> lights) <a class="anchor-link" href="#refreshUniformsLights"
              title="Permalink to WebGLRenderer.refreshUniformsLights">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsLights ( Map&lt;String, Uniform&gt; uniforms, Map lights ) {

		uniforms["ambientLightColor"].value = lights["ambient"];

		uniforms["directionalLightColor"].value = lights["directional"]["colors"];
		uniforms["directionalLightDirection"].value = lights["directional"]["positions"];

		uniforms["pointLightColor"].value = lights["point"]["colors"];
		uniforms["pointLightPosition"].value = lights["point"]["positions"];
		uniforms["pointLightDistance"].value = lights["point"]["distances"];

		uniforms["spotLightColor"].value = lights["spot"]["colors"];
		uniforms["spotLightPosition"].value = lights["spot"]["positions"];
		uniforms["spotLightDistance"].value = lights["spot"]["distances"];
		uniforms["spotLightDirection"].value = lights["spot"]["directions"];
		uniforms["spotLightAngle"].value = lights["spot"]["angles"];
		uniforms["spotLightExponent"].value = lights["spot"]["exponents"];

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsLine">
<span class="show-code">Code</span>
<strong>refreshUniformsLine</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsLine"
              title="Permalink to WebGLRenderer.refreshUniformsLine">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsLine ( uniforms, material ) {

		uniforms["diffuse"].value = material.color;
		uniforms["opacity"].value = material.opacity;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsParticle">
<span class="show-code">Code</span>
<strong>refreshUniformsParticle</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsParticle"
              title="Permalink to WebGLRenderer.refreshUniformsParticle">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsParticle ( uniforms, material ) {

		uniforms["psColor"].value = material.color;
		uniforms["opacity"].value = material.opacity;
		uniforms["size"].value = material.size;
		uniforms["scale"].value = canvas.height / 2.0; // TODO: Cache 

		uniforms["map"].texture = material.map;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsPhong">
<span class="show-code">Code</span>
<strong>refreshUniformsPhong</strong>(uniforms, material) <a class="anchor-link" href="#refreshUniformsPhong"
              title="Permalink to WebGLRenderer.refreshUniformsPhong">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsPhong ( uniforms, material ) {

		uniforms["shininess"].value = material.shininess;

		if ( gammaInput ) {

			uniforms["ambient"].value.copyGammaToLinear( material.ambient );
			uniforms["emissive"].value.copyGammaToLinear( material.emissive );
			uniforms["specular"].value.copyGammaToLinear( material.specular );

		} else {

			uniforms["ambient"].value = material.ambient;
			uniforms["emissive"].value = material.emissive;
			uniforms["specular"].value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms["wrapRGB"].value.copy( material.wrapRGB );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="refreshUniformsShadow">
<span class="show-code">Code</span>
<strong>refreshUniformsShadow</strong>(uniforms, lights) <a class="anchor-link" href="#refreshUniformsShadow"
              title="Permalink to WebGLRenderer.refreshUniformsShadow">#</a></h4>
<div class="doc">

<pre class="source">
refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms["shadowMatrix"] ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i &lt; il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light is SpotLight || ( light is DirectionalLight &amp;&amp; ! light.shadowCascade ) ) {

					uniforms["shadowMap"].texture[ j ] = light.shadowMap;
					uniforms["shadowMapSize"].value[ j ] = light.shadowMapSize;

					uniforms["shadowMatrix"].value[ j ] = light.shadowMatrix;

					uniforms["shadowDarkness"].value[ j ] = light.shadowDarkness;
					uniforms["shadowBias"].value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="removeInstances">
<span class="show-code">Code</span>
<strong>removeInstances</strong>(objlist, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#removeInstances"
              title="Permalink to WebGLRenderer.removeInstances">#</a></h4>
<div class="doc">

<pre class="source">
removeInstances ( objlist, WebGLObject object ) {

		for ( var o = objlist.length - 1; o &gt;= 0; o -- ) {

			if ( objlist[ o ].object == object ) {

				objlist.splice( o, 1 );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="removeInstancesDirect">
<span class="show-code">Code</span>
<strong>removeInstancesDirect</strong>(objlist, object) <a class="anchor-link" href="#removeInstancesDirect"
              title="Permalink to WebGLRenderer.removeInstancesDirect">#</a></h4>
<div class="doc">

<pre class="source">
removeInstancesDirect ( objlist, object ) {

		for ( var o = objlist.length - 1; o &gt;= 0; o -- ) {

			if ( objlist[ o ] === object ) {

				objlist.splice( o, 1 );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="removeObject">
<span class="show-code">Code</span>
<strong>removeObject</strong>(<a href="../ThreeD/WebGLObject.html">WebGLObject</a> webglobject, scene) <a class="anchor-link" href="#removeObject"
              title="Permalink to WebGLRenderer.removeObject">#</a></h4>
<div class="doc">

<pre class="source">
removeObject ( WebGLObject webglobject, scene ) {

	  Object3D object = webglobject.object;
	  
		if ( object is Mesh  ||
			 object is ParticleSystem ||
			 object is Ribbon ||
			 object is Line ) {

			removeInstances( scene["__webglObjects"], webglobject );

		} else if ( object is Sprite ) {

			removeInstancesDirect( scene["__webglSprites"], webglobject );

		} else if ( object is LensFlare ) {

			removeInstancesDirect( scene["__webglFlares"], webglobject );

		} else if ( object is ImmediateRenderObject || (object["immediateRenderCallback"] != null) ) {

			removeInstances( scene["__webglObjectsImmediate"], webglobject );

		}

		webglobject.__webglActive = false;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="render">
<span class="show-code">Code</span>
<strong>render</strong>(<a href="../ThreeD/Scene.html">Scene</a> scene, <a href="../ThreeD/Camera.html">Camera</a> camera) <a class="anchor-link" href="#render"
              title="Permalink to WebGLRenderer.render">#</a></h4>
<div class="doc">

<pre class="source">
render ( Scene scene, Camera camera) =&gt; _render( scene, camera);
</pre>
</div>
</div>
<div class="method"><h4 id="renderBuffer">
<span class="show-code">Code</span>
<strong>renderBuffer</strong>(camera, lights, fog, material, <a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#renderBuffer"
              title="Permalink to WebGLRenderer.renderBuffer">#</a></h4>
<div class="doc">

<pre class="source">
renderBuffer ( camera, lights, fog, material, WebGLGeometry geometryGroup, WebGLObject webglobject ) {

	  Object3D object = webglobject.object;
	  
		if ( !material.visible ) return;

		var program, attributes, linewidth, primitives, a, attribute, i, il;

		program = setProgram( camera, lights, fog, material, webglobject );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		// vertices

		if ( !material.morphTargets &amp;&amp; attributes["position"] &gt;= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.vertexAttribPointer( attributes["position"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

			}

		} else {

			if ( webglobject.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, webglobject );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList != null) {

			  il = geometryGroup.__webglCustomAttributesList.length;
				for ( i = 0; i &lt; il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if( attributes[ attribute.buffer.belongsToAttribute ] &gt;= 0 ) {

						_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, attribute.buffer );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, WebGLRenderingContext.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes["color"] &gt;= 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.vertexAttribPointer( attributes["color"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

			}

			// normals

			if ( attributes["normal"] &gt;= 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.vertexAttribPointer( attributes["normal"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes["tangent"] &gt;= 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.vertexAttribPointer( attributes["tangent"], 4, WebGLRenderingContext.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes["uv"] &gt;= 0 ) {

				if ( geometryGroup.__webglUVBuffer != null ) {

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.vertexAttribPointer( attributes["uv"], 2, WebGLRenderingContext.FLOAT, false, 0, 0 );

					_gl.enableVertexAttribArray( attributes["uv"] );

				} else {

					_gl.disableVertexAttribArray( attributes["uv"] );

				}

			}

			if ( attributes["uv2"] &gt;= 0 ) {

				if ( geometryGroup.__webglUV2Buffer != null) {

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.vertexAttribPointer( attributes["uv2"], 2, WebGLRenderingContext.FLOAT, false, 0, 0 );

					_gl.enableVertexAttribArray( attributes["uv2"] );

				} else {

					_gl.disableVertexAttribArray( attributes["uv2"] );

				}

			}

			if ( material.skinning &amp;&amp;
				 attributes["skinVertexA"] &gt;= 0 &amp;&amp; attributes["skinVertexB"] &gt;= 0 &amp;&amp;
				 attributes["skinIndex"] &gt;= 0 &amp;&amp; attributes["skinWeight"] &gt;= 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinVertexABuffer );
				_gl.vertexAttribPointer( attributes["skinVertexA"], 4, WebGLRenderingContext.FLOAT, false, 0, 0 );

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinVertexBBuffer );
				_gl.vertexAttribPointer( attributes["skinVertexB"], 4, WebGLRenderingContext.FLOAT, false, 0, 0 );

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.vertexAttribPointer( attributes["skinIndex"], 4, WebGLRenderingContext.FLOAT, false, 0, 0 );

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.vertexAttribPointer( attributes["skinWeight"], 4, WebGLRenderingContext.FLOAT, false, 0, 0 );

			}

		}

		// render mesh

		if ( object is Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( WebGLRenderingContext.LINES, geometryGroup.__webglLineCount, WebGLRenderingContext.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( WebGLRenderingContext.TRIANGLES, geometryGroup.__webglFaceCount, WebGLRenderingContext.UNSIGNED_SHORT, 0 );

			}

			info.render.calls ++;
			info.render.vertices += geometryGroup.__webglFaceCount;
			info.render.faces += (geometryGroup.__webglFaceCount / 3).toInt();

		// render lines

		} else if ( object is Line ) {

			primitives = ( (object as Line).type == LineStrip ) ? WebGLRenderingContext.LINE_STRIP : WebGLRenderingContext.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			info.render.calls ++;

		// render particles

		} else if ( object is ParticleSystem ) {

			_gl.drawArrays( WebGLRenderingContext.POINTS, 0, geometryGroup.__webglParticleCount );

			info.render.calls ++;
			info.render.points += geometryGroup.__webglParticleCount;

		// render ribbon

		} else if ( object is Ribbon ) {

			_gl.drawArrays( WebGLRenderingContext.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );

			info.render.calls ++;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderBufferDirect">
<span class="show-code">Code</span>
<strong>renderBufferDirect</strong>(camera, lights, fog, material, geometry, object) <a class="anchor-link" href="#renderBufferDirect"
              title="Permalink to WebGLRenderer.renderBufferDirect">#</a></h4>
<div class="doc">

<pre class="source">
renderBufferDirect ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var program, attributes, linewidth, primitives, a, attribute;

		program = setProgram( camera, lights, fog, material, object );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		// render mesh

		if ( object is Mesh ) {

			var offsets = geometry.offsets;

			// if there is more than 1 chunk
			// must set attribute pointers to use new offsets for each chunk
			// even if geometry and materials didn't change

			if ( offsets.length &gt; 1 ) updateBuffers = true;

			for ( var i = 0, il = offsets.length; i &lt; il; ++ i ) {

				var startIndex = offsets[ i ].index;

				if ( updateBuffers ) {

					// vertices

					var position = geometry.attributes[ "position" ];
					var positionSize = position.itemSize;

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, position.buffer );
					_gl.vertexAttribPointer( attributes["position"], positionSize, WebGLRenderingContext.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32

					// normals

					var normal = geometry.attributes[ "normal" ];

					if ( attributes["normal"] &gt;= 0 &amp;&amp; normal ) {

						var normalSize = normal.itemSize;

						_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, normal.buffer );
						_gl.vertexAttribPointer( attributes["normal"], normalSize, WebGLRenderingContext.FLOAT, false, 0, startIndex * normalSize * 4 );

					}

					// uvs

					var uv = geometry.attributes[ "uv" ];

					if ( attributes["uv"] &gt;= 0 &amp;&amp; uv ) {

						if ( uv.buffer ) {

							var uvSize = uv.itemSize;

							_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, uv.buffer );
							_gl.vertexAttribPointer( attributes["uv"], uvSize, WebGLRenderingContext.FLOAT, false, 0, startIndex * uvSize * 4 );

							_gl.enableVertexAttribArray( attributes["uv"] );

						} else {

							_gl.disableVertexAttribArray( attributes["uv"] );

						}

					}

					// colors

					var color = geometry.attributes[ "color" ];

					if ( attributes["color"] &gt;= 0 &amp;&amp; color ) {

						var colorSize = color.itemSize;

						_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, color.buffer );
						_gl.vertexAttribPointer( attributes["color"], colorSize, WebGLRenderingContext.FLOAT, false, 0, startIndex * colorSize * 4 );

					}

					// tangents

					var tangent = geometry.attributes[ "tangent" ];

					if ( attributes["tangent"] &gt;= 0 &amp;&amp; tangent ) {

						var tangentSize = tangent.itemSize;

						_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, tangent.buffer );
						_gl.vertexAttribPointer( attributes["tangent"], tangentSize, WebGLRenderingContext.FLOAT, false, 0, startIndex * tangentSize * 4 );

					}

					// indices

					var index = geometry.attributes[ "index" ];

					_gl.bindBuffer( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, index.buffer );

				}

				// render indexed triangles

				_gl.drawElements( WebGLRenderingContext.TRIANGLES, offsets[ i ].count, WebGLRenderingContext.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

				info.render.calls ++;
				info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
				info.render.faces += offsets[ i ].count / 3;

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderBufferImmediate">
<span class="show-code">Code</span>
<strong>renderBufferImmediate</strong>(object, program, material) <a class="anchor-link" href="#renderBufferImmediate"
              title="Permalink to WebGLRenderer.renderBufferImmediate">#</a></h4>
<div class="doc">

<pre class="source">
renderBufferImmediate ( object, program, material ) {

		if ( object.hasPositions &amp;&amp; ! object["__webglVertexBuffer"] ) object["__webglVertexBuffer"] = _gl.createBuffer();
		if ( object.hasNormals &amp;&amp; ! object["__webglNormalBuffer"] ) object["__webglNormalBuffer"] = _gl.createBuffer();
		if ( object.hasUvs &amp;&amp; ! object["__webglUVBuffer"] ) object["__webglUVBuffer"] = _gl.createBuffer();
		if ( object.hasColors &amp;&amp; ! object["__webglColorBuffer"] ) object["__webglColorBuffer"] = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, object["__webglVertexBuffer"] );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, object.positionArray, WebGLRenderingContext.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["position"] );
			_gl.vertexAttribPointer( program.attributes["position"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, object["__webglNormalBuffer"] );

			if ( material.shading === Three.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i &lt; il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, object.normalArray, WebGLRenderingContext.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["normal"] );
			_gl.vertexAttribPointer( program.attributes["normal"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs &amp;&amp; material.map ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, object["__webglUVBuffer"] );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, object.uvArray, WebGLRenderingContext.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["uv"] );
			_gl.vertexAttribPointer( program.attributes["uv"], 2, WebGLRenderingContext.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors &amp;&amp; material.vertexColors !== Three.NoColors ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, object["__webglColorBuffer"] );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, object.colorArray, WebGLRenderingContext.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes["color"] );
			_gl.vertexAttribPointer( program.attributes["color"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( WebGLRenderingContext.TRIANGLES, 0, object.count );

		object.count = 0;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderImmediateObject">
<span class="show-code">Code</span>
<strong>renderImmediateObject</strong>(camera, lights, fog, material, object) <a class="anchor-link" href="#renderImmediateObject"
              title="Permalink to WebGLRenderer.renderImmediateObject">#</a></h4>
<div class="doc">

<pre class="source">
renderImmediateObject( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function( object ) { renderBufferImmediate( object, program, material ); } );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderObjects">
<span class="show-code">Code</span>
<strong>renderObjects</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../ThreeD/WebGLObject.html">WebGLObject</a>&gt; renderList, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> reverse, <a href="http://api.dartlang.org/dart_core/String.html">String</a> materialType, <a href="../ThreeD/WebGLCamera.html">WebGLCamera</a> camera, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../ThreeD/Light.html">Light</a>&gt; lights, fog, useBlending, [overrideMaterial = null]) <a class="anchor-link" href="#renderObjects"
              title="Permalink to WebGLRenderer.renderObjects">#</a></h4>
<div class="doc">

<pre class="source">
renderObjects (  List&lt;WebGLObject&gt;renderList, 
	                 bool reverse, String materialType, 
	                 WebGLCamera camera, 
	                 List&lt;Light&gt; lights, 
	                 fog, 
	                 useBlending, 
	                 [overrideMaterial = null] ) {

		WebGLObject webglObject;
		var object, buffer, material;
		num start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i !== end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial != null ) {

					material = overrideMaterial;

				} else {

					material = (materialType == "opaque")? webglObject.opaque : webglObject.transparent;

					if ( material == null ) continue;

					if ( useBlending ) setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				setMaterialFaces( material );

				if ( buffer is BufferGeometry ) {

					renderBufferDirect( camera, lights, fog, material, buffer, webglObject );

				} else {

					renderBuffer( camera, lights, fog, material, buffer, webglObject );

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderObjectsImmediate">
<span class="show-code">Code</span>
<strong>renderObjectsImmediate</strong>(renderList, materialType, camera, lights, fog, useBlending, [overrideMaterial]) <a class="anchor-link" href="#renderObjectsImmediate"
              title="Permalink to WebGLRenderer.renderObjectsImmediate">#</a></h4>
<div class="doc">

<pre class="source">
renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, [overrideMaterial] ) {

		var webglObject, object, material, program, il;

		il = renderList.length;

		for ( var i = 0; i &lt; il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					setDepthTest( material.depthTest );
					setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="renderPlugins">
<span class="show-code">Code</span>
<strong>renderPlugins</strong>(plugins, scene, camera) <a class="anchor-link" href="#renderPlugins"
              title="Permalink to WebGLRenderer.renderPlugins">#</a></h4>
<div class="doc">

<pre class="source">
renderPlugins( plugins, scene, camera ) {

		if ( plugins.isEmpty() ) return;

		var il = plugins.length;
		
		for ( var i = 0; i &lt; il; i ++ ) {

			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setBlending">
<span class="show-code">Code</span>
<strong>setBlending</strong>(blending, [blendEquation, blendSrc, blendDst]) <a class="anchor-link" href="#setBlending"
              title="Permalink to WebGLRenderer.setBlending">#</a></h4>
<div class="doc">

<pre class="source">
setBlending( blending, [blendEquation, blendSrc, blendDst] ) {

		if ( blending !== _oldBlending ) {

			if ( blending === Three.NoBlending ) {

				_gl.disable( WebGLRenderingContext.BLEND );

			} else if ( blending === Three.AdditiveBlending ) {

				_gl.enable( WebGLRenderingContext.BLEND );
				_gl.blendEquation( WebGLRenderingContext.FUNC_ADD );
				_gl.blendFunc( WebGLRenderingContext.SRC_ALPHA, WebGLRenderingContext.ONE );

			} else if ( blending === Three.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( WebGLRenderingContext.BLEND );
				_gl.blendEquation( WebGLRenderingContext.FUNC_ADD );
				_gl.blendFunc( WebGLRenderingContext.ZERO, WebGLRenderingContext.ONE_MINUS_SRC_COLOR );

			} else if ( blending === Three.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( WebGLRenderingContext.BLEND );
				_gl.blendEquation( WebGLRenderingContext.FUNC_ADD );
				_gl.blendFunc( WebGLRenderingContext.ZERO, WebGLRenderingContext.SRC_COLOR );

			} else if ( blending === Three.CustomBlending ) {

				_gl.enable( WebGLRenderingContext.BLEND );

			} else {

				_gl.enable( WebGLRenderingContext.BLEND );
				_gl.blendEquationSeparate( WebGLRenderingContext.FUNC_ADD, WebGLRenderingContext.FUNC_ADD );
				_gl.blendFuncSeparate( WebGLRenderingContext.SRC_ALPHA, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA, WebGLRenderingContext.ONE, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === Three.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setClearColor">
<span class="show-code">Code</span>
<strong>setClearColor</strong>(color, alpha) <a class="anchor-link" href="#setClearColor"
              title="Permalink to WebGLRenderer.setClearColor">#</a></h4>
<div class="doc">

<pre class="source">
setClearColor( color, alpha ) {

		clearColor.copy( color );
		clearAlpha = alpha;

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setClearColorHex">
<span class="show-code">Code</span>
<strong>setClearColorHex</strong>(hex, alpha) <a class="anchor-link" href="#setClearColorHex"
              title="Permalink to WebGLRenderer.setClearColorHex">#</a></h4>
<div class="doc">

<pre class="source">
setClearColorHex( hex, alpha ) {

		clearColor.setHex( hex );
		clearAlpha = alpha;

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setCubeTexture">
<span class="show-code">Code</span>
<strong>setCubeTexture</strong>(<a href="../ThreeD/Texture.html">Texture</a> texture, slot) <a class="anchor-link" href="#setCubeTexture"
              title="Permalink to WebGLRenderer.setCubeTexture">#</a></h4>
<div class="doc">

<pre class="source">
setCubeTexture ( Texture texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image["__webglTextureCube"] ) {

					texture.image["__webglTextureCube"] = _gl.createTexture();

				}

				_gl.activeTexture( WebGLRenderingContext.TEXTURE0 + slot );
				_gl.bindTexture( WebGLRenderingContext.TEXTURE_CUBE_MAP, texture.image["__webglTextureCube"] );

				_gl.pixelStorei( WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, (texture.flipY) ? 1 : 0 );

				var cubeImage = [];

				for ( var i = 0; i &lt; 6; i ++ ) {

					if ( autoScaleCubemaps ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( (image as Dynamic).width ) &amp;&amp; isPowerOfTwo( (image as Dynamic).height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( WebGLRenderingContext.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i &lt; 6; i ++ ) {

					_gl.texImage2D( WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

				}

				if ( texture.generateMipmaps &amp;&amp; isImagePowerOfTwo ) {

					_gl.generateMipmap( WebGLRenderingContext.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( WebGLRenderingContext.TEXTURE0 + slot );
				_gl.bindTexture( WebGLRenderingContext.TEXTURE_CUBE_MAP, texture.image["__webglTextureCube"] );

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setCubeTextureDynamic">
<span class="show-code">Code</span>
<strong>setCubeTextureDynamic</strong>(texture, slot) <a class="anchor-link" href="#setCubeTextureDynamic"
              title="Permalink to WebGLRenderer.setCubeTextureDynamic">#</a></h4>
<div class="doc">

<pre class="source">
setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( WebGLRenderingContext.TEXTURE0 + slot );
		_gl.bindTexture( WebGLRenderingContext.TEXTURE_CUBE_MAP, texture["__webglTexture"] );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDefaultGLState">
<span class="show-code">Code</span>
<strong>setDefaultGLState</strong>() <a class="anchor-link" href="#setDefaultGLState"
              title="Permalink to WebGLRenderer.setDefaultGLState">#</a></h4>
<div class="doc">

<pre class="source">
setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( WebGLRenderingContext.DEPTH_TEST );
		_gl.depthFunc( WebGLRenderingContext.LEQUAL );

		_gl.frontFace( WebGLRenderingContext.CCW );
		_gl.cullFace( WebGLRenderingContext.BACK );
		_gl.enable( WebGLRenderingContext.CULL_FACE );

		_gl.enable( WebGLRenderingContext.BLEND );
		_gl.blendEquation( WebGLRenderingContext.FUNC_ADD );
		_gl.blendFunc( WebGLRenderingContext.SRC_ALPHA, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA );

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDepthTest">
<span class="show-code">Code</span>
<strong>setDepthTest</strong>(depthTest) <a class="anchor-link" href="#setDepthTest"
              title="Permalink to WebGLRenderer.setDepthTest">#</a></h4>
<div class="doc">

<pre class="source">
setDepthTest( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( WebGLRenderingContext.DEPTH_TEST );

			} else {

				_gl.disable( WebGLRenderingContext.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDepthWrite">
<span class="show-code">Code</span>
<strong>setDepthWrite</strong>(depthWrite) <a class="anchor-link" href="#setDepthWrite"
              title="Permalink to WebGLRenderer.setDepthWrite">#</a></h4>
<div class="doc">

<pre class="source">
setDepthWrite( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setDirectBuffers">
<span class="show-code">Code</span>
<strong>setDirectBuffers</strong>(geometry, hint, dispose) <a class="anchor-link" href="#setDirectBuffers"
              title="Permalink to WebGLRenderer.setDirectBuffers">#</a></h4>
<div class="doc">

<pre class="source">
setDirectBuffers ( geometry, hint, dispose ) {

		var attributes = geometry.attributes;

		var index = attributes[ "index" ];
		var position = attributes[ "position" ];
		var normal = attributes[ "normal" ];
		var uv = attributes[ "uv" ];
		var color = attributes[ "color" ];
		var tangent = attributes[ "tangent" ];

		if ( geometry.elementsNeedUpdate &amp;&amp; index != null ) {

			_gl.bindBuffer( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, index.buffer );
			_gl.bufferData( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, index.array, hint );

		}

		if ( geometry.verticesNeedUpdate &amp;&amp; position != null ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, position.buffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, position.array, hint );

		}

		if ( geometry.normalsNeedUpdate &amp;&amp; normal != null ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, normal.buffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, normal.array, hint );

		}

		if ( geometry.uvsNeedUpdate &amp;&amp; uv != null ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, uv.buffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, uv.array, hint );

		}

		if ( geometry.colorsNeedUpdate &amp;&amp; color != null ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, color.buffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, color.array, hint );

		}

		if ( geometry.tangentsNeedUpdate &amp;&amp; tangent != null ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, tangent.buffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, tangent.array, hint );

		}

		if ( dispose ) {

			for ( var i in geometry.attributes ) {

				geometry.attributes[ i ].array = null; //delete geometry.attributes[ i ].array;
			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setFaceCulling">
<span class="show-code">Code</span>
<strong>setFaceCulling</strong>(cullFace, frontFace) <a class="anchor-link" href="#setFaceCulling"
              title="Permalink to WebGLRenderer.setFaceCulling">#</a></h4>
<div class="doc">

<pre class="source">
setFaceCulling( cullFace, frontFace ) {

		if ( cullFace ) {

			if ( !frontFace || frontFace === "ccw" ) {

				_gl.frontFace( WebGLRenderingContext.CCW );

			} else {

				_gl.frontFace( WebGLRenderingContext.CW );

			}

			if( cullFace === "back" ) {

				_gl.cullFace( WebGLRenderingContext.BACK );

			} else if( cullFace === "front" ) {

				_gl.cullFace( WebGLRenderingContext.FRONT );

			} else {

				_gl.cullFace( WebGLRenderingContext.FRONT_AND_BACK );

			}

			_gl.enable( WebGLRenderingContext.CULL_FACE );

		} else {

			_gl.disable( WebGLRenderingContext.CULL_FACE );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setLineBuffers">
<span class="show-code">Code</span>
<strong>setLineBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry, hint) <a class="anchor-link" href="#setLineBuffers"
              title="Permalink to WebGLRenderer.setLineBuffers">#</a></h4>
<div class="doc">

<pre class="source">
setLineBuffers ( WebGLGeometry geometry, hint ) {

		var v, c, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		vl = vertices.length,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c &lt; cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes != null ) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &amp;&amp;
					 ( customAttribute.boundTo == null ||
					   customAttribute.boundTo == "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setLineWidth">
<span class="show-code">Code</span>
<strong>setLineWidth</strong>(width) <a class="anchor-link" href="#setLineWidth"
              title="Permalink to WebGLRenderer.setLineWidth">#</a></h4>
<div class="doc">

<pre class="source">
setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setMaterialFaces">
<span class="show-code">Code</span>
<strong>setMaterialFaces</strong>(material) <a class="anchor-link" href="#setMaterialFaces"
              title="Permalink to WebGLRenderer.setMaterialFaces">#</a></h4>
<div class="doc">

<pre class="source">
setMaterialFaces( material ) {

		var doubleSided = material.side === Three.DoubleSide;
		var flipSided = material.side === Three.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( WebGLRenderingContext.CULL_FACE );

			} else {

				_gl.enable( WebGLRenderingContext.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( WebGLRenderingContext.CW );

			} else {

				_gl.frontFace( WebGLRenderingContext.CCW );

			}

			_oldFlipSided = flipSided;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setMaterialShaders">
<span class="show-code">Code</span>
<strong>setMaterialShaders</strong>(<a href="../ThreeD/WebGLMaterial.html">WebGLMaterial</a> material, shaders) <a class="anchor-link" href="#setMaterialShaders"
              title="Permalink to WebGLRenderer.setMaterialShaders">#</a></h4>
<div class="doc">

<pre class="source">
setMaterialShaders( WebGLMaterial material, shaders ) {

		material.uniforms = UniformsUtils.clone( shaders["uniforms"] );
		material.vertexShader = shaders["vertexShader"];
		material.fragmentShader = shaders["fragmentShader"];

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setMeshBuffers">
<span class="show-code">Code</span>
<strong>setMeshBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object, hint, dispose, material) <a class="anchor-link" href="#setMeshBuffers"
              title="Permalink to WebGLRenderer.setMeshBuffers">#</a></h4>
<div class="doc">

<pre class="source">
setMeshBuffers( WebGLGeometry geometryGroup, WebGLObject object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {
   
			// console.log( object );
			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === Three.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinVertexAArray = geometryGroup.__skinVertexAArray,
		skinVertexBArray = geometryGroup.__skinVertexBArray,
		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.webglgeometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		chunk_faces4 = geometryGroup.faces4,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = (geometry.faceVertexUvs.length &gt; 1) ? geometry.faceVertexUvs[ 1 ] : null,
		
		obj_colors = geometry.colors,

		obj_skinVerticesA = geometry.skinVerticesA,
		obj_skinVerticesB = geometry.skinVerticesB,
		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		
		if ( dirtyVertices ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];
				v4 = vertices[ face.d ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				vertexArray[ offset + 9 ]  = v4.x;
				vertexArray[ offset + 10 ] = v4.y;
				vertexArray[ offset + 11 ] = v4.z;

				offset += 12;

			}

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			vkl = morphTargets.length;
			for ( vk = 0; vk &lt; vkl; vk ++ ) {

				offset_morphTarget = 0;

				fl = chunk_faces3.length;
				for ( f = 0; f &lt; fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				fl = chunk_faces4.length;
				for ( f = 0; f &lt; fl; f ++ ) {

					chf = chunk_faces4[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];
					v4 = morphTargets[ vk ].vertices[ face.d ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					vka[ offset_morphTarget + 9 ]  = v4.x;
					vka[ offset_morphTarget + 10 ] = v4.y;
					vka[ offset_morphTarget + 11 ] = v4.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;
							n4 = faceVertexNormals.d;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;
							n4 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

						nka[ offset_morphTarget + 9 ]  = n4.x;
						nka[ offset_morphTarget + 10 ] = n4.y;
						nka[ offset_morphTarget + 11 ] = n4.z;

					}

					//

					offset_morphTarget += 12;

				}

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( !obj_skinWeights.isEmpty()) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				// vertices A

				sa1 = obj_skinVerticesA[ face.a ];
				sa2 = obj_skinVerticesA[ face.b ];
				sa3 = obj_skinVerticesA[ face.c ];

				skinVertexAArray[ offset_skin ]     = sa1.x;
				skinVertexAArray[ offset_skin + 1 ] = sa1.y;
				skinVertexAArray[ offset_skin + 2 ] = sa1.z;
				skinVertexAArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexAArray[ offset_skin + 4 ] = sa2.x;
				skinVertexAArray[ offset_skin + 5 ] = sa2.y;
				skinVertexAArray[ offset_skin + 6 ] = sa2.z;
				skinVertexAArray[ offset_skin + 7 ] = 1;

				skinVertexAArray[ offset_skin + 8 ]  = sa3.x;
				skinVertexAArray[ offset_skin + 9 ]  = sa3.y;
				skinVertexAArray[ offset_skin + 10 ] = sa3.z;
				skinVertexAArray[ offset_skin + 11 ] = 1;

				// vertices B

				sb1 = obj_skinVerticesB[ face.a ];
				sb2 = obj_skinVerticesB[ face.b ];
				sb3 = obj_skinVerticesB[ face.c ];

				skinVertexBArray[ offset_skin ]     = sb1.x;
				skinVertexBArray[ offset_skin + 1 ] = sb1.y;
				skinVertexBArray[ offset_skin + 2 ] = sb1.z;
				skinVertexBArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexBArray[ offset_skin + 4 ] = sb2.x;
				skinVertexBArray[ offset_skin + 5 ] = sb2.y;
				skinVertexBArray[ offset_skin + 6 ] = sb2.z;
				skinVertexBArray[ offset_skin + 7 ] = 1;

				skinVertexBArray[ offset_skin + 8 ]  = sb3.x;
				skinVertexBArray[ offset_skin + 9 ]  = sb3.y;
				skinVertexBArray[ offset_skin + 10 ] = sb3.z;
				skinVertexBArray[ offset_skin + 11 ] = 1;

				offset_skin += 12;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];
				sw4 = obj_skinWeights[ face.d ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				skinWeightArray[ offset_skin + 12 ] = sw4.x;
				skinWeightArray[ offset_skin + 13 ] = sw4.y;
				skinWeightArray[ offset_skin + 14 ] = sw4.z;
				skinWeightArray[ offset_skin + 15 ] = sw4.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];
				si4 = obj_skinIndices[ face.d ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				skinIndexArray[ offset_skin + 12 ] = si4.x;
				skinIndexArray[ offset_skin + 13 ] = si4.y;
				skinIndexArray[ offset_skin + 14 ] = si4.z;
				skinIndexArray[ offset_skin + 15 ] = si4.w;

				// vertices A

				sa1 = obj_skinVerticesA[ face.a ];
				sa2 = obj_skinVerticesA[ face.b ];
				sa3 = obj_skinVerticesA[ face.c ];
				sa4 = obj_skinVerticesA[ face.d ];

				skinVertexAArray[ offset_skin ]     = sa1.x;
				skinVertexAArray[ offset_skin + 1 ] = sa1.y;
				skinVertexAArray[ offset_skin + 2 ] = sa1.z;
				skinVertexAArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexAArray[ offset_skin + 4 ] = sa2.x;
				skinVertexAArray[ offset_skin + 5 ] = sa2.y;
				skinVertexAArray[ offset_skin + 6 ] = sa2.z;
				skinVertexAArray[ offset_skin + 7 ] = 1;

				skinVertexAArray[ offset_skin + 8 ]  = sa3.x;
				skinVertexAArray[ offset_skin + 9 ]  = sa3.y;
				skinVertexAArray[ offset_skin + 10 ] = sa3.z;
				skinVertexAArray[ offset_skin + 11 ] = 1;

				skinVertexAArray[ offset_skin + 12 ] = sa4.x;
				skinVertexAArray[ offset_skin + 13 ] = sa4.y;
				skinVertexAArray[ offset_skin + 14 ] = sa4.z;
				skinVertexAArray[ offset_skin + 15 ] = 1;

				// vertices B

				sb1 = obj_skinVerticesB[ face.a ];
				sb2 = obj_skinVerticesB[ face.b ];
				sb3 = obj_skinVerticesB[ face.c ];
				sb4 = obj_skinVerticesB[ face.d ];

				skinVertexBArray[ offset_skin ]     = sb1.x;
				skinVertexBArray[ offset_skin + 1 ] = sb1.y;
				skinVertexBArray[ offset_skin + 2 ] = sb1.z;
				skinVertexBArray[ offset_skin + 3 ] = 1; // pad for faster vertex shader

				skinVertexBArray[ offset_skin + 4 ] = sb2.x;
				skinVertexBArray[ offset_skin + 5 ] = sb2.y;
				skinVertexBArray[ offset_skin + 6 ] = sb2.z;
				skinVertexBArray[ offset_skin + 7 ] = 1;

				skinVertexBArray[ offset_skin + 8 ]  = sb3.x;
				skinVertexBArray[ offset_skin + 9 ]  = sb3.y;
				skinVertexBArray[ offset_skin + 10 ] = sb3.z;
				skinVertexBArray[ offset_skin + 11 ] = 1;

				skinVertexBArray[ offset_skin + 12 ] = sb4.x;
				skinVertexBArray[ offset_skin + 13 ] = sb4.y;
				skinVertexBArray[ offset_skin + 14 ] = sb4.z;
				skinVertexBArray[ offset_skin + 15 ] = 1;

				offset_skin += 16;

			}

			if ( offset_skin &gt; 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinVertexABuffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, skinVertexAArray, hint );

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinVertexBBuffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, skinVertexBArray, hint );

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors &amp;&amp; vertexColorType ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 &amp;&amp; vertexColorType === Three.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 4 &amp;&amp; vertexColorType === Three.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];
					c4 = vertexColors[ 3 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;
					c4 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				colorArray[ offset_color + 9 ]  = c4.r;
				colorArray[ offset_color + 10 ] = c4.g;
				colorArray[ offset_color + 11 ] = c4.b;

				offset_color += 12;

			}

			if ( offset_color &gt; 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents &amp;&amp; geometry.hasTangents ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];
				t4 = vertexTangents[ 3 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				tangentArray[ offset_tangent + 12 ] = t4.x;
				tangentArray[ offset_tangent + 13 ] = t4.y;
				tangentArray[ offset_tangent + 14 ] = t4.z;
				tangentArray[ offset_tangent + 15 ] = t4.w;

				offset_tangent += 16;

			}

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals &amp;&amp; (normalType != Three.NoShading) ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 &amp;&amp; needsSmoothNormals ) {

					for ( i = 0; i &lt; 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i &lt; 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 4 &amp;&amp; needsSmoothNormals ) {

					for ( i = 0; i &lt; 4; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i &lt; 4; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs &amp;&amp; !obj_uvs.isEmpty() &amp;&amp; uvType ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces3[ f ];

				face = obj_faces[ fi ];
				uv = obj_uvs[ fi ];

				if ( uv == null ) continue;

				for ( i = 0; i &lt; 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces4[ f ];

				face = obj_faces[ fi ];
				uv = obj_uvs[ fi ];

				if ( uv == null ) continue;

				for ( i = 0; i &lt; 4; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.u;
					uvArray[ offset_uv + 1 ] = uvi.v;

					offset_uv += 2;

				}

			}

			if ( offset_uv &gt; 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs &amp;&amp; (obj_uvs2 != null) &amp;&amp; uvType ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces3[ f ];

				face = obj_faces[ fi ];
				uv2 = obj_uvs2[ fi ];

				if ( uv2 == null ) continue;

				for ( i = 0; i &lt; 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				fi = chunk_faces4[ f ];

				face = obj_faces[ fi ];
				uv2 = obj_uvs2[ fi ];

				if ( uv2 == null ) continue;

				for ( i = 0; i &lt; 4; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.u;
					uv2Array[ offset_uv2 + 1 ] = uv2i.v;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 &gt; 0 ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			fl = chunk_faces3.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			 fl = chunk_faces4.length;
			for ( f = 0; f &lt; fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				faceArray[ offset_face ]     = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 3;

				faceArray[ offset_face + 3 ] = vertexIndex + 1;
				faceArray[ offset_face + 4 ] = vertexIndex + 2;
				faceArray[ offset_face + 5 ] = vertexIndex + 3;

				offset_face += 6;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 3;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				lineArray[ offset_line + 6 ] = vertexIndex + 2;
				lineArray[ offset_line + 7 ] = vertexIndex + 3;

				offset_line += 8;

				vertexIndex += 4;

			}

			_gl.bindBuffer( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( WebGLRenderingContext.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes != null) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo === "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
							customAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];

							offset_custom += 4;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;
							customAttribute.array[ offset_custom + 3 ] = value;

							offset_custom += 4;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo == null || customAttribute.boundTo == "vertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						fl = chunk_faces3.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						fl = chunk_faces4.length;
						for ( f = 0; f &lt; fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					}

				}

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			geometryGroup.__inittedArrays = null; //delete geometryGroup.__inittedArrays"];
			geometryGroup.__colorArray = null; //delete geometryGroup.__colorArray"];
			geometryGroup.__normalArray = null; //delete geometryGroup.__normalArray"];
			geometryGroup.__tangentArray = null; //delete geometryGroup.__tangentArray"];
			geometryGroup.__uvArray = null; //delete geometryGroup.__uvArray"];
			geometryGroup.__uv2Array = null; //delete geometryGroup.__uv2Array"];
			geometryGroup.__faceArray = null; //delete geometryGroup.__faceArray"];
			geometryGroup.__vertexArray = null; //delete geometryGroup.__vertexArray"];
			geometryGroup.__lineArray = null; //delete geometryGroup.__lineArray"];
			geometryGroup.__skinVertexAArray = null; //delete geometryGroup.__skinVertexAArray"];
			geometryGroup.__skinVertexBArray = null; //delete geometryGroup.__skinVertexBArray"];
			geometryGroup.__skinIndexArray = null; //delete geometryGroup.__skinIndexArray"];
			geometryGroup.__skinWeightArray = null; //delete geometryGroup.__skinWeightArray"];

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setParticleBuffers">
<span class="show-code">Code</span>
<strong>setParticleBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry, hint, object) <a class="anchor-link" href="#setParticleBuffers"
              title="Permalink to WebGLRenderer.setParticleBuffers">#</a></h4>
<div class="doc">

<pre class="source">
setParticleBuffers ( WebGLGeometry geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiplySelf( object.matrixWorld );

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_projScreenMatrixPS.multiplyVector3( _vector3 );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( function( a, b ) { return b[ 0 ] - a[ 0 ]; } );

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c &lt; cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes != null ) {

				il = customAttributes.length;
				for ( i = 0; i &lt; il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo == null || customAttribute.boundTo === "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca &lt; cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v &lt; vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c &lt; cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes != null) {

				il = customAttributes.length;
				for ( i = 0; i &lt; il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &amp;&amp;
						 ( customAttribute.boundTo == null ||
						   customAttribute.boundTo == "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === "c" ) {

								for ( ca = 0; ca &lt; cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca &lt; cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca &lt; cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes != null) {

			il = customAttributes.length;
			for ( i = 0; i &lt; il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	}
</pre>
</div>
</div>
<div class="method"><h4 id="setPolygonOffset">
<span class="show-code">Code</span>
<strong>setPolygonOffset</strong>(polygonoffset, factor, units) <a class="anchor-link" href="#setPolygonOffset"
              title="Permalink to WebGLRenderer.setPolygonOffset">#</a></h4>
<div class="doc">

<pre class="source">
setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( WebGLRenderingContext.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( WebGLRenderingContext.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset &amp;&amp; ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setProgram">
<span class="show-code">Code</span>
<strong>setProgram</strong>(<a href="../ThreeD/WebGLCamera.html">WebGLCamera</a> camera, <a href="http://api.dartlang.org/dart_core/List.html">List</a> lights, <a href="../ThreeD/Fog.html">Fog</a> fog, <a href="../ThreeD/WebGLMaterial.html">WebGLMaterial</a> material, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#setProgram"
              title="Permalink to WebGLRenderer.setProgram">#</a></h4>
<div class="doc">

<pre class="source">
setProgram( WebGLCamera camera, List lights, Fog fog, WebGLMaterial material, WebGLObject object ) {

		if ( material.needsUpdate ) {

			if ( material.program != null ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

		if ( program !== _currentProgram ) {

			_gl.useProgram( program.glProgram );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

		if ( refreshMaterial || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms["projectionMatrix"], false, camera._projectionMatrixArray );

			if ( camera !== _currentCamera ) _currentCamera = camera;

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( (fog != null) &amp;&amp; material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshPhongMaterial ||
				 material.isMeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material.isMeshBasicMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isMeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material.isParticleBasicMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				m_uniforms["mNear"].value = camera.near;
				m_uniforms["mFar"].value = camera.far;
				m_uniforms["opacity"].value = material.opacity;

			} else if ( material.isMeshNormalMaterial ) {

				m_uniforms["opacity"].value = material.opacity;

			}

			if ( object.receiveShadow &amp;&amp; ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				 material.isMeshPhongMaterial ||
				 (material.envMap != null) ) {

				if ( p_uniforms["cameraPosition"] !== null ) {

					var position = camera.matrixWorld.getPosition();
					_gl.uniform3f( p_uniforms["cameraPosition"], position.x, position.y, position.z );

				}

			}

			if ( material.isMeshPhongMaterial ||
				 material.isMeshLambertMaterial ||
				 material.isShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms["viewMatrix"] !== null ) {

					_gl.uniformMatrix4fv( p_uniforms["viewMatrix"], false, camera._viewMatrixArray );

				}

			}

		}

		if ( material.skinning ) {

			if ( supportsBoneTextures &amp;&amp; object.useVertexTexture ) {

				if ( p_uniforms["boneTexture"] !== null ) {

					// shadowMap texture array starts from 6
					// texture unit 12 should leave space for 6 shadowmaps

					var textureUnit = 12;

					_gl.uniform1i( p_uniforms["boneTexture"], textureUnit );
					setTexture( object.boneTexture, textureUnit );

				}

			} else {

				if ( p_uniforms["boneGlobalMatrices"] !== null ) {

					_gl.uniformMatrix4fv( p_uniforms["boneGlobalMatrices"], false, object.boneMatrices );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms["modelMatrix"] !== null ) {

			_gl.uniformMatrix4fv( p_uniforms["modelMatrix"], false, object.matrixWorld.elements );

		}

		return program;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setRenderTarget">
<span class="show-code">Code</span>
<strong>setRenderTarget</strong>(<a href="../ThreeD/WebGLRenderTarget.html">WebGLRenderTarget</a> renderTarget) <a class="anchor-link" href="#setRenderTarget"
              title="Permalink to WebGLRenderer.setRenderTarget">#</a></h4>
<div class="doc">

<pre class="source">
setRenderTarget ( WebGLRenderTarget renderTarget ) {

		var isCube = ( renderTarget is WebGLRenderTargetCube );

		if ( (renderTarget != null ) &amp;&amp; ( renderTarget.__webglFramebuffer == null) ) {

			if ( renderTarget.depthBuffer == null ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer == null ) renderTarget.stencilBuffer = true;

			renderTarget.__webglTexture = _gl.createTexture();

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) &amp;&amp; isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( WebGLRenderingContext.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( WebGLRenderingContext.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i &lt; 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( WebGLRenderingContext.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();
				renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				_gl.bindTexture( WebGLRenderingContext.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( WebGLRenderingContext.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( WebGLRenderingContext.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, WebGLRenderingContext.TEXTURE_2D );
				setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( WebGLRenderingContext.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( WebGLRenderingContext.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( WebGLRenderingContext.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( WebGLRenderingContext.RENDERBUFFER, null );
			_gl.bindFramebuffer( WebGLRenderingContext.FRAMEBUFFER, null);

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget != null ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ (renderTarget as WebGLRenderTargetCube).activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( WebGLRenderingContext.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setRibbonBuffers">
<span class="show-code">Code</span>
<strong>setRibbonBuffers</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry, hint) <a class="anchor-link" href="#setRibbonBuffers"
              title="Permalink to WebGLRenderer.setRibbonBuffers">#</a></h4>
<div class="doc">

<pre class="source">
setRibbonBuffers ( WebGLGeometry geometry, hint ) {

		var v, c, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		vl = vertices.length,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate;

		if ( dirtyVertices ) {

			for ( v = 0; v &lt; vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c &lt; cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( WebGLRenderingContext.ARRAY_BUFFER, colorArray, hint );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setScissor">
<span class="show-code">Code</span>
<strong>setScissor</strong>(x, y, width, height) <a class="anchor-link" href="#setScissor"
              title="Permalink to WebGLRenderer.setScissor">#</a></h4>
<div class="doc">

<pre class="source">
setScissor( x, y, width, height ) {
		_gl.scissor( x, y, width, height );
	}
</pre>
</div>
</div>
<div class="method"><h4 id="setSize">
<span class="show-code">Code</span>
<strong>setSize</strong>(width, height) <a class="anchor-link" href="#setSize"
              title="Permalink to WebGLRenderer.setSize">#</a></h4>
<div class="doc">

<pre class="source">
setSize( width, height ) {
		canvas.width = width;
		canvas.height = height;

		setViewport( 0, 0, canvas.width, canvas.height );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setTexture">
<span class="show-code">Code</span>
<strong>setTexture</strong>(texture, slot) <a class="anchor-link" href="#setTexture"
              title="Permalink to WebGLRenderer.setTexture">#</a></h4>
<div class="doc">

<pre class="source">
setTexture( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( texture["__webglInit"] == null ) {

				texture["__webglInit"] = true;
				texture["__webglTexture"] = _gl.createTexture();

				info.memory.textures ++;

			}

			_gl.activeTexture( WebGLRenderingContext.TEXTURE0 + slot );
			_gl.bindTexture( WebGLRenderingContext.TEXTURE_2D, texture["__webglTexture"] );

			_gl.pixelStorei( WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, (texture.flipY) ? 1 : 0 );
			_gl.pixelStorei( WebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, (texture.premultiplyAlpha) ? 1 : 0 );
     
			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image.width ) &amp;&amp; isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( WebGLRenderingContext.TEXTURE_2D, texture, isImagePowerOfTwo );

			if ( texture is DataTexture ) {

				_gl.texImage2D( WebGLRenderingContext.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			} else {

				_gl.texImage2D( WebGLRenderingContext.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

			if ( texture.generateMipmaps &amp;&amp; isImagePowerOfTwo ) _gl.generateMipmap( WebGLRenderingContext.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate != null ) texture.onUpdate();

		} else {

			_gl.activeTexture( WebGLRenderingContext.TEXTURE0 + slot );
			_gl.bindTexture( WebGLRenderingContext.TEXTURE_2D, texture["__webglTexture"] );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setTextureParameters">
<span class="show-code">Code</span>
<strong>setTextureParameters</strong>(textureType, texture, isImagePowerOfTwo) <a class="anchor-link" href="#setTextureParameters"
              title="Permalink to WebGLRenderer.setTextureParameters">#</a></h4>
<div class="doc">

<pre class="source">
setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_WRAP_S, WebGLRenderingContext.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_WRAP_T, WebGLRenderingContext.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, WebGLRenderingContext.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}
		
		if ( (_glExtensionTextureFilterAnisotropic != null) &amp;&amp; texture.type !== Three.FloatType ) {

			if ( texture.anisotropy &gt; 1 || ( texture["__oldAnisotropy"] != null) ) {

				_gl.texParameterf( textureType, EXTTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, maxAnisotropy ) );
				texture["__oldAnisotropy"] = texture.anisotropy;

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setViewport">
<span class="show-code">Code</span>
<strong>setViewport</strong>([x = 0, y = 0, width = -1, height = -1]) <a class="anchor-link" href="#setViewport"
              title="Permalink to WebGLRenderer.setViewport">#</a></h4>
<div class="doc">

<pre class="source">
setViewport( [x = 0, y = 0, width = -1, height = -1] ) {

		_viewportX = x;
		_viewportY = y;


		_viewportWidth = (width != -1) ? width : canvas.width;
		_viewportHeight = (height != -1)? height : canvas.height;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupFrameBuffer">
<span class="show-code">Code</span>
<strong>setupFrameBuffer</strong>(framebuffer, renderTarget, textureTarget) <a class="anchor-link" href="#setupFrameBuffer"
              title="Permalink to WebGLRenderer.setupFrameBuffer">#</a></h4>
<div class="doc">

<pre class="source">
setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( WebGLRenderingContext.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( WebGLRenderingContext.FRAMEBUFFER, WebGLRenderingContext.COLOR_ATTACHMENT0, textureTarget, renderTarget["__webglTexture"], 0 );

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupLights">
<span class="show-code">Code</span>
<strong>setupLights</strong>(<a href="../ThreeD/Program.html">Program</a> program, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../ThreeD/Light.html">Light</a>&gt; lights) <a class="anchor-link" href="#setupLights"
              title="Permalink to WebGLRenderer.setupLights">#</a></h4>
<div class="doc">

<pre class="source">
setupLights ( Program program, List&lt;Light&gt; lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, position, intensity, distance,

		zlights = _lights;

		List dcolors = zlights["directional"]["colors"],
		     dpositions = zlights["directional"]["positions"],
		     
		     pcolors = zlights["point"]["colors"],
		     ppositions = zlights["point"]["positions"],
     	 pdistances = zlights["point"]["distances"],
     
     	 scolors = zlights["spot"]["colors"],
     	 spositions = zlights["spot"]["positions"],
     	 sdistances = zlights["spot"]["distances"],
     	 sdirections = zlights["spot"]["directions"],
     	 sangles = zlights["spot"]["angles"],
     	 sexponents = zlights["spot"]["exponents"];

		var dlength = 0,
   		plength = 0,
   		slength = 0,
   
   		doffset = 0,
   		poffset = 0,
   		soffset = 0;

		ll = lights.length;
		for ( l = 0; l &lt; ll; l ++ ) {

			light = lights[ l ];

			// TODO - Setup proper interfaces for Light to avoid type checks
			if ( (((light is DirectionalLight) || (light is SpotLight)) &amp;&amp; (light as Dynamic).onlyShadow) || 
			    ! light.visible ) continue;

			color = light.color;
			
			if ( (light is DirectionalLight) || (light is SpotLight) || (light is PointLight)) {
 			intensity = (light as Dynamic).intensity;
 			distance = (light as Dynamic).distance;
			}
			
			if ( light is AmbientLight ) {

				if ( gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light is DirectionalLight ) {

				doffset = dlength * 3;

				// Grow the lists
				dcolors.length = doffset + 3;
				dpositions.length = doffset + 3;
				
				if ( gammaInput ) {

					dcolors[ doffset ]     = color.r * color.r * intensity * intensity;
					dcolors[ doffset + 1 ] = color.g * color.g * intensity * intensity;
					dcolors[ doffset + 2 ] = color.b * color.b * intensity * intensity;

				} else {

					dcolors[ doffset ]     = color.r * intensity;
					dcolors[ doffset + 1 ] = color.g * intensity;
					dcolors[ doffset + 2 ] = color.b * intensity;

				}

				_direction.copy( light.matrixWorld.getPosition() );
				_direction.subSelf( light.target.matrixWorld.getPosition() );
				_direction.normalize();

				dpositions[ doffset ]     = _direction.x;
				dpositions[ doffset + 1 ] = _direction.y;
				dpositions[ doffset + 2 ] = _direction.z;

				dlength += 1;

			} else if( light is PointLight ) {

				poffset = plength * 3;

       // Grow the lists
				pcolors.length = poffset + 3;
				ppositions.length = poffset + 3;
				
				if ( gammaInput ) {

					pcolors[ poffset ]     = color.r * color.r * intensity * intensity;
					pcolors[ poffset + 1 ] = color.g * color.g * intensity * intensity;
					pcolors[ poffset + 2 ] = color.b * color.b * intensity * intensity;

				} else {

					pcolors[ poffset ]     = color.r * intensity;
					pcolors[ poffset + 1 ] = color.g * intensity;
					pcolors[ poffset + 2 ] = color.b * intensity;

				}

				position = light.matrixWorld.getPosition();

				ppositions[ poffset ]     = position.x;
				ppositions[ poffset + 1 ] = position.y;
				ppositions[ poffset + 2 ] = position.z;

				if (pdistances==null) { pdistances = new List(); pdistances.add(0); }
				if (pdistances.length == 0) {pdistances.add(0);}
				pdistances[ plength ] = distance;

				plength += 1;

			} else if( light is SpotLight ) {

				soffset = slength * 3;

       // Grow the lists
				scolors.length = soffset + 3;
				spositions.length = soffset + 3;
				sdirections.length = soffset + 3;
				sdistances.length = slength + 1;
				
				if ( gammaInput ) {

					scolors[ soffset ]     = color.r * color.r * intensity * intensity;
					scolors[ soffset + 1 ] = color.g * color.g * intensity * intensity;
					scolors[ soffset + 2 ] = color.b * color.b * intensity * intensity;

				} else {

					scolors[ soffset ]     = color.r * intensity;
					scolors[ soffset + 1 ] = color.g * intensity;
					scolors[ soffset + 2 ] = color.b * intensity;

				}

				position = light.matrixWorld.getPosition();

				spositions[ soffset ]     = position.x;
				spositions[ soffset + 1 ] = position.y;
				spositions[ soffset + 2 ] = position.z;

				sdistances[ slength ] = distance;

				_direction.copy( position );
				_direction.subSelf( light.target.matrixWorld.getPosition() );
				_direction.normalize();

				sdirections[ soffset ]     = _direction.x;
				sdirections[ soffset + 1 ] = _direction.y;
				sdirections[ soffset + 2 ] = _direction.z;

				sangles[ slength ] = Math.cos( light.angle );
				sexponents[ slength ] = light.exponent;

				slength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		ll = dcolors.length; for ( l = dlength * 3; l &lt; ll; l ++ ) dcolors[ l ] = 0.0;
		ll = pcolors.length; for ( l = plength * 3; l &lt; ll; l ++ ) pcolors[ l ] = 0.0;
		ll = scolors.length; for ( l = slength * 3; l &lt; ll; l ++ ) scolors[ l ] = 0.0;

		zlights["directional"]["length"] = dlength;
		zlights["point"]["length"] = plength;
		zlights["spot"]["length"] = slength;

		zlights["ambient"][ 0 ] = r;
		zlights["ambient"][ 1 ] = g;
		zlights["ambient"][ 2 ] = b;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupMatrices">
<span class="show-code">Code</span>
<strong>setupMatrices</strong>(<a href="../ThreeD/WebGLObject.html">WebGLObject</a> object, <a href="../ThreeD/WebGLCamera.html">WebGLCamera</a> camera) <a class="anchor-link" href="#setupMatrices"
              title="Permalink to WebGLRenderer.setupMatrices">#</a></h4>
<div class="doc">

<pre class="source">
setupMatrices ( WebGLObject object, WebGLCamera camera ) {

		object._modelViewMatrix.multiply( camera.matrixWorldInverse, object.matrixWorld );

		object._normalMatrix.getInverse( object._modelViewMatrix );
		object._normalMatrix.transpose();

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupMorphTargets">
<span class="show-code">Code</span>
<strong>setupMorphTargets</strong>(material, <a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometryGroup, <a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#setupMorphTargets"
              title="Permalink to WebGLRenderer.setupMorphTargets">#</a></h4>
<div class="doc">

<pre class="source">
setupMorphTargets ( material, WebGLGeometry geometryGroup, WebGLObject object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== -1 ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			_gl.vertexAttribPointer( attributes["position"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

		} else if ( attributes["position"] &gt;= 0 ) {

			_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.vertexAttribPointer( attributes["position"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m &lt; material.numSupportedMorphTargets &amp;&amp; m &lt; order.length ) {

				_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
				_gl.vertexAttribPointer( attributes[ "morphTarget$m"], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

				if ( material.morphNormals ) {

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal$m" ], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence;
			List&lt;List&gt; activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i &lt; il; i ++ ) {

				influence = influences[ i ];

				if ( influence &gt; 0 ) {

					activeInfluenceIndices.add( [ i, influence ] );

				}

			}

			if ( activeInfluenceIndices.length &gt; material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length &gt; material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.add( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m &lt; material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] != null &amp;&amp; !activeInfluenceIndices[ m ].isEmpty()) {

					influenceIndex = activeInfluenceIndices[ m ][ 0 ];

					_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );

					_gl.vertexAttribPointer( attributes[ "morphTarget$m" ], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.bindBuffer( WebGLRenderingContext.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal$m" ], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					_gl.vertexAttribPointer( attributes[ "morphTarget$m" ], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal$m" ], 3, WebGLRenderingContext.FLOAT, false, 0, 0 );

					}

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms["morphTargetInfluences"] !== null ) {

			_gl.uniform1fv( material.program.uniforms["morphTargetInfluences"], object.__webglMorphTargetInfluences );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="setupRenderBuffer">
<span class="show-code">Code</span>
<strong>setupRenderBuffer</strong>(renderbuffer, renderTarget) <a class="anchor-link" href="#setupRenderBuffer"
              title="Permalink to WebGLRenderer.setupRenderBuffer">#</a></h4>
<div class="doc">

<pre class="source">
setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( WebGLRenderingContext.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer &amp;&amp; ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( WebGLRenderingContext.RENDERBUFFER, WebGLRenderingContext.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( WebGLRenderingContext.FRAMEBUFFER, WebGLRenderingContext.DEPTH_ATTACHMENT, WebGLRenderingContext.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( WebGLRenderingContext.RENDERBUFFER, WebGLRenderingContext.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( WebGLRenderingContext.FRAMEBUFFER, WebGLRenderingContext.STENCIL_ATTACHMENT, WebGLRenderingContext.RENDERBUFFER, renderbuffer );
		*/
		} else if( renderTarget.depthBuffer &amp;&amp; renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( WebGLRenderingContext.RENDERBUFFER, WebGLRenderingContext.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( WebGLRenderingContext.FRAMEBUFFER, WebGLRenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGLRenderingContext.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( WebGLRenderingContext.RENDERBUFFER, WebGLRenderingContext.RGBA4, renderTarget.width, renderTarget.height );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="sortFacesByMaterial">
<span class="show-code">Code</span>
<strong>sortFacesByMaterial</strong>(<a href="../ThreeD/WebGLGeometry.html">WebGLGeometry</a> geometry) <a class="anchor-link" href="#sortFacesByMaterial"
              title="Permalink to WebGLRenderer.sortFacesByMaterial">#</a></h4>
<div class="doc">

<pre class="source">
sortFacesByMaterial ( WebGLGeometry geometry ) {

		var f, fl, face, materialIndex, vertices,
			materialHash, groupHash;
		
		Map&lt;String, Map&gt; hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		geometry.geometryGroups = {};

		fl = geometry.faces.length;
		for ( f = 0; f &lt; fl; f ++ ) {

			face = geometry.faces[ f ];
			materialIndex = face.materialIndex;

			var materialHash = ( materialIndex != null ) ? materialIndex.toString() : (-1).toString();

			if ( hash_map[ materialHash ] == null ) {

				hash_map[ materialHash ] = { 'hash': materialHash, 'counter': 0 };

			}

			groupHash = "${hash_map[ materialHash ]["hash"]}_${hash_map[ materialHash ]["counter"]}";

			if ( geometry.geometryGroups[ groupHash ] == null ) {

				geometry.geometryGroups[ groupHash ] = new WebGLGeometry(faces3: [], faces4: [], materialIndex: materialIndex, vertices: 0, numMorphTargets: numMorphTargets, numMorphNormals: numMorphNormals);

			}

			vertices = face is Face3 ? 3 : 4;

			if ( geometry.geometryGroups[ groupHash ].vertices + vertices &gt; 65535 ) {

				hash_map[ materialHash ]["counter"] += 1;
				groupHash = "${hash_map[ materialHash ]["hash"]}_${hash_map[ materialHash ]["counter"]}";

				if ( geometry.geometryGroups[ groupHash ] == null ) {

					geometry.geometryGroups[ groupHash ] = new WebGLGeometry(faces3: [], faces4: [], materialIndex: materialIndex, vertices: 0, numMorphTargets: numMorphTargets, numMorphNormals: numMorphNormals );

				}

			}

			if ( face is Face3 ) {

				geometry.geometryGroups[ groupHash ].faces3.add( f );

			} else {

				geometry.geometryGroups[ groupHash ].faces4.add( f );

			}

			geometry.geometryGroups[ groupHash ].vertices += vertices;

		}

		geometry.geometryGroupsList = [];

		geometry.geometryGroups.forEach( (k,g) {
		  
     g.id = _geometryGroupCounter ++;
     
     geometry.geometryGroupsList.add( g );

   });
				
		return;

	}
</pre>
</div>
</div>
<div class="method"><h4 id="unrollBufferMaterial">
<span class="show-code">Code</span>
<strong>unrollBufferMaterial</strong>(<a href="../ThreeD/WebGLObject.html">WebGLObject</a> object) <a class="anchor-link" href="#unrollBufferMaterial"
              title="Permalink to WebGLRenderer.unrollBufferMaterial">#</a></h4>
<div class="doc">

<pre class="source">
unrollBufferMaterial ( WebGLObject object ) {

		WebGLGeometry	buffer = object.buffer;
		WebGLMaterial meshMaterial = object.webglmaterial;
		int materialIndex;
		WebGLMaterial material;

		
		if ( object.material is MeshFaceMaterial ) {

			materialIndex = buffer.materialIndex;

			if ( materialIndex &gt;= 0 ) {

				material = new WebGLMaterial.from(object.geometry.materials[ materialIndex ]);

				if ( material.transparent ) {

				  object.transparent = material;
				  object.opaque = null;

				} else {

				  object.opaque = material;
				  object.transparent = null;

				}

			}

		} else {

		  material = meshMaterial;
		  
			if ( material != null ) {

				if ( material.transparent != null ) {

				  object.transparent = material;
				  object.opaque = null;

				} else {

				  object.opaque = material;
				  object.transparent = null;

				}

			}

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="unrollImmediateBufferMaterial">
<span class="show-code">Code</span>
<strong>unrollImmediateBufferMaterial</strong>(<a href="../ThreeD/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#unrollImmediateBufferMaterial"
              title="Permalink to WebGLRenderer.unrollImmediateBufferMaterial">#</a></h4>
<div class="doc">

<pre class="source">
unrollImmediateBufferMaterial ( WebGLObject webglobject ) {

		var material = webglobject.webglmaterial;

		if ( material.transparent ) {

		  webglobject.transparent = material;
		  webglobject.opaque = null;

		} else {

		  webglobject.opaque = material;
		  webglobject.transparent = null;

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="updateObject">
<span class="show-code">Code</span>
<strong>updateObject</strong>(<a href="../ThreeD/WebGLObject.html">WebGLObject</a> webglobject) <a class="anchor-link" href="#updateObject"
              title="Permalink to WebGLRenderer.updateObject">#</a></h4>
<div class="doc">

<pre class="source">
updateObject ( WebGLObject webglobject ) {
	  
   Object3D object = webglobject.object;
		WebGLGeometry geometry = webglobject.webglgeometry, geometryGroup;
		var customAttributesDirty;
		
		WebGLMaterial material;

		if ( object is Mesh ) {

			if ( object.geometry is BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {

					setDirectBuffers( geometry, WebGLRenderingContext.DYNAMIC_DRAW, !(geometry as Dynamic) );

				}

				geometry.verticesNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

			} else {

				// check all geometry groups

				for( var i = 0, il = geometry.geometryGroupsList.length; i &lt; il; i ++ ) {

					geometryGroup = geometry.geometryGroupsList[ i ];

					material = getBufferMaterial( webglobject, geometryGroup );

					customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

						setMeshBuffers( geometryGroup, webglobject, WebGLRenderingContext.DYNAMIC_DRAW, !geometry.isDynamic, material );

					}

				}

				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

				if (material.attributes != null) {
				  clearCustomAttributes( material );
				}

			}

		} else if ( object is Ribbon ) {

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {

				setRibbonBuffers( geometry, WebGLRenderingContext.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

		} else if ( object is Line ) {

			material = getBufferMaterial( webglobject, geometryGroup );

			customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate ||  geometry.colorsNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, WebGLRenderingContext.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			if (material.attributes != null) clearCustomAttributes( material );

		} else if ( object is ParticleSystem ) {

			material = getBufferMaterial( webglobject, geometryGroup );

			customAttributesDirty = (material.attributes != null) &amp;&amp; areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, WebGLRenderingContext.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			if (material.attributes != null) clearCustomAttributes( material );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="updateRenderTargetMipmap">
<span class="show-code">Code</span>
<strong>updateRenderTargetMipmap</strong>(renderTarget) <a class="anchor-link" href="#updateRenderTargetMipmap"
              title="Permalink to WebGLRenderer.updateRenderTargetMipmap">#</a></h4>
<div class="doc">

<pre class="source">
updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget is WebGLRenderTargetCube ) {

			_gl.bindTexture( WebGLRenderingContext.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( WebGLRenderingContext.TEXTURE_CUBE_MAP );
			_gl.bindTexture( WebGLRenderingContext.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( WebGLRenderingContext.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( WebGLRenderingContext.TEXTURE_2D );
			_gl.bindTexture( WebGLRenderingContext.TEXTURE_2D, null );

		}

	}
</pre>
</div>
</div>
<div class="method"><h4 id="updateShadowMap">
<span class="show-code">Code</span>
<strong>updateShadowMap</strong>(scene, camera) <a class="anchor-link" href="#updateShadowMap"
              title="Permalink to WebGLRenderer.updateShadowMap">#</a></h4>
<div class="doc">

<pre class="source">
updateShadowMap( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		shadowMapPlugin.update( scene, camera );

	}
</pre>
</div>
</div>
<h3>Fields</h3>
<div class="field"><h4 id="alpha">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>alpha</strong> <a class="anchor-link"
            href="#alpha"
            title="Permalink to WebGLRenderer.alpha">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool alpha, 
		   premultipliedAlpha, 
		   antialias, 
		   stencil, 
		   preserveDrawingBuffer;
</pre>
</div>
</div>
<div class="field"><h4 id="antialias">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>antialias</strong> <a class="anchor-link"
            href="#antialias"
            title="Permalink to WebGLRenderer.antialias">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool alpha, 
		   premultipliedAlpha, 
		   antialias, 
		   stencil, 
		   preserveDrawingBuffer;
</pre>
</div>
</div>
<div class="field"><h4 id="autoClear">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClear</strong> <a class="anchor-link"
            href="#autoClear"
            title="Permalink to WebGLRenderer.autoClear">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool autoClear,
		autoClearColor,
		autoClearDepth,
		autoClearStencil;
</pre>
</div>
</div>
<div class="field"><h4 id="autoClearColor">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClearColor</strong> <a class="anchor-link"
            href="#autoClearColor"
            title="Permalink to WebGLRenderer.autoClearColor">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool autoClear,
		autoClearColor,
		autoClearDepth,
		autoClearStencil;
</pre>
</div>
</div>
<div class="field"><h4 id="autoClearDepth">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClearDepth</strong> <a class="anchor-link"
            href="#autoClearDepth"
            title="Permalink to WebGLRenderer.autoClearDepth">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool autoClear,
		autoClearColor,
		autoClearDepth,
		autoClearStencil;
</pre>
</div>
</div>
<div class="field"><h4 id="autoClearStencil">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoClearStencil</strong> <a class="anchor-link"
            href="#autoClearStencil"
            title="Permalink to WebGLRenderer.autoClearStencil">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool autoClear,
		autoClearColor,
		autoClearDepth,
		autoClearStencil;
</pre>
</div>
</div>
<div class="field"><h4 id="autoScaleCubemaps">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoScaleCubemaps</strong> <a class="anchor-link"
            href="#autoScaleCubemaps"
            title="Permalink to WebGLRenderer.autoScaleCubemaps">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool autoScaleCubemaps;
</pre>
</div>
</div>
<div class="field"><h4 id="autoUpdateObjects">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoUpdateObjects</strong> <a class="anchor-link"
            href="#autoUpdateObjects"
            title="Permalink to WebGLRenderer.autoUpdateObjects">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool sortObjects,
	autoUpdateObjects,
	autoUpdateScene;
</pre>
</div>
</div>
<div class="field"><h4 id="autoUpdateScene">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>autoUpdateScene</strong> <a class="anchor-link"
            href="#autoUpdateScene"
            title="Permalink to WebGLRenderer.autoUpdateScene">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool sortObjects,
	autoUpdateObjects,
	autoUpdateScene;
</pre>
</div>
</div>
<div class="field"><h4 id="canvas">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_html/CanvasElement.html">CanvasElement</a>         <strong>canvas</strong> <a class="anchor-link"
            href="#canvas"
            title="Permalink to WebGLRenderer.canvas">#</a>
        </h4>
        <div class="doc">

<pre class="source">
CanvasElement canvas;
</pre>
</div>
</div>
<div class="field"><h4 id="clearAlpha">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>clearAlpha</strong> <a class="anchor-link"
            href="#clearAlpha"
            title="Permalink to WebGLRenderer.clearAlpha">#</a>
        </h4>
        <div class="doc">

<pre class="source">
num clearAlpha;
</pre>
</div>
</div>
<div class="field"><h4 id="clearColor">
<span class="show-code">Code</span>
<a href="../ThreeD/Color.html">Color</a>         <strong>clearColor</strong> <a class="anchor-link"
            href="#clearColor"
            title="Permalink to WebGLRenderer.clearColor">#</a>
        </h4>
        <div class="doc">

<pre class="source">
Color clearColor;
</pre>
</div>
</div>
<div class="field"><h4 id="gammaInput">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>gammaInput</strong> <a class="anchor-link"
            href="#gammaInput"
            title="Permalink to WebGLRenderer.gammaInput">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool gammaInput,
	gammaOutput,
	physicallyBasedShading;
</pre>
</div>
</div>
<div class="field"><h4 id="gammaOutput">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>gammaOutput</strong> <a class="anchor-link"
            href="#gammaOutput"
            title="Permalink to WebGLRenderer.gammaOutput">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool gammaInput,
	gammaOutput,
	physicallyBasedShading;
</pre>
</div>
</div>
<div class="field"><h4 id="info">
<span class="show-code">Code</span>
<a href="../ThreeD/WebGLRendererInfo.html">WebGLRendererInfo</a>         <strong>info</strong> <a class="anchor-link"
            href="#info"
            title="Permalink to WebGLRenderer.info">#</a>
        </h4>
        <div class="doc">

<pre class="source">
WebGLRendererInfo info;
</pre>
</div>
</div>
<div class="field"><h4 id="maxAnisotropy">
<span class="show-code">Code</span>
var         <strong>maxAnisotropy</strong> <a class="anchor-link"
            href="#maxAnisotropy"
            title="Permalink to WebGLRenderer.maxAnisotropy">#</a>
        </h4>
        <div class="doc">

<pre class="source">
var maxAnisotropy;
</pre>
</div>
</div>
<div class="field"><h4 id="maxCubemapSize">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxCubemapSize</strong> <a class="anchor-link"
            href="#maxCubemapSize"
            title="Permalink to WebGLRenderer.maxCubemapSize">#</a>
        </h4>
        <div class="doc">

<pre class="source">
num maxVertexTextures, maxTextureSize, maxCubemapSize;
</pre>
</div>
</div>
<div class="field"><h4 id="maxLights">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>maxLights</strong> <a class="anchor-link"
            href="#maxLights"
            title="Permalink to WebGLRenderer.maxLights">#</a>
        </h4>
        <div class="doc">

<pre class="source">
int maxLights;
</pre>
</div>
</div>
<div class="field"><h4 id="maxMorphNormals">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>maxMorphNormals</strong> <a class="anchor-link"
            href="#maxMorphNormals"
            title="Permalink to WebGLRenderer.maxMorphNormals">#</a>
        </h4>
        <div class="doc">

<pre class="source">
int maxMorphTargets,
		maxMorphNormals;
</pre>
</div>
</div>
<div class="field"><h4 id="maxMorphTargets">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>maxMorphTargets</strong> <a class="anchor-link"
            href="#maxMorphTargets"
            title="Permalink to WebGLRenderer.maxMorphTargets">#</a>
        </h4>
        <div class="doc">

<pre class="source">
int maxMorphTargets,
		maxMorphNormals;
</pre>
</div>
</div>
<div class="field"><h4 id="maxTextureSize">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxTextureSize</strong> <a class="anchor-link"
            href="#maxTextureSize"
            title="Permalink to WebGLRenderer.maxTextureSize">#</a>
        </h4>
        <div class="doc">

<pre class="source">
num maxVertexTextures, maxTextureSize, maxCubemapSize;
</pre>
</div>
</div>
<div class="field"><h4 id="maxVertexTextures">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>maxVertexTextures</strong> <a class="anchor-link"
            href="#maxVertexTextures"
            title="Permalink to WebGLRenderer.maxVertexTextures">#</a>
        </h4>
        <div class="doc">

<pre class="source">
num maxVertexTextures, maxTextureSize, maxCubemapSize;
</pre>
</div>
</div>
<div class="field"><h4 id="physicallyBasedShading">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>physicallyBasedShading</strong> <a class="anchor-link"
            href="#physicallyBasedShading"
            title="Permalink to WebGLRenderer.physicallyBasedShading">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool gammaInput,
	gammaOutput,
	physicallyBasedShading;
</pre>
</div>
</div>
<div class="field"><h4 id="precision">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>precision</strong> <a class="anchor-link"
            href="#precision"
            title="Permalink to WebGLRenderer.precision">#</a>
        </h4>
        <div class="doc">

<pre class="source">
String precision;
</pre>
</div>
</div>
<div class="field"><h4 id="premultipliedAlpha">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>premultipliedAlpha</strong> <a class="anchor-link"
            href="#premultipliedAlpha"
            title="Permalink to WebGLRenderer.premultipliedAlpha">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool alpha, 
		   premultipliedAlpha, 
		   antialias, 
		   stencil, 
		   preserveDrawingBuffer;
</pre>
</div>
</div>
<div class="field"><h4 id="preserveDrawingBuffer">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>preserveDrawingBuffer</strong> <a class="anchor-link"
            href="#preserveDrawingBuffer"
            title="Permalink to WebGLRenderer.preserveDrawingBuffer">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool alpha, 
		   premultipliedAlpha, 
		   antialias, 
		   stencil, 
		   preserveDrawingBuffer;
</pre>
</div>
</div>
<div class="field"><h4 id="renderPluginsPost">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>         <strong>renderPluginsPost</strong> <a class="anchor-link"
            href="#renderPluginsPost"
            title="Permalink to WebGLRenderer.renderPluginsPost">#</a>
        </h4>
        <div class="doc">

<pre class="source">
List renderPluginsPre,
		renderPluginsPost;
</pre>
</div>
</div>
<div class="field"><h4 id="renderPluginsPre">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>         <strong>renderPluginsPre</strong> <a class="anchor-link"
            href="#renderPluginsPre"
            title="Permalink to WebGLRenderer.renderPluginsPre">#</a>
        </h4>
        <div class="doc">

<pre class="source">
List renderPluginsPre,
		renderPluginsPost;
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapAutoUpdate">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapAutoUpdate</strong> <a class="anchor-link"
            href="#shadowMapAutoUpdate"
            title="Permalink to WebGLRenderer.shadowMapAutoUpdate">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapSoft,
	shadowMapCullFrontFaces,
	shadowMapDebug,
	shadowMapCascade;
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapCascade">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapCascade</strong> <a class="anchor-link"
            href="#shadowMapCascade"
            title="Permalink to WebGLRenderer.shadowMapCascade">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapSoft,
	shadowMapCullFrontFaces,
	shadowMapDebug,
	shadowMapCascade;
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapCullFrontFaces">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapCullFrontFaces</strong> <a class="anchor-link"
            href="#shadowMapCullFrontFaces"
            title="Permalink to WebGLRenderer.shadowMapCullFrontFaces">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapSoft,
	shadowMapCullFrontFaces,
	shadowMapDebug,
	shadowMapCascade;
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapDebug">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapDebug</strong> <a class="anchor-link"
            href="#shadowMapDebug"
            title="Permalink to WebGLRenderer.shadowMapDebug">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapSoft,
	shadowMapCullFrontFaces,
	shadowMapDebug,
	shadowMapCascade;
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapEnabled">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapEnabled</strong> <a class="anchor-link"
            href="#shadowMapEnabled"
            title="Permalink to WebGLRenderer.shadowMapEnabled">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapSoft,
	shadowMapCullFrontFaces,
	shadowMapDebug,
	shadowMapCascade;
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapPlugin">
<span class="show-code">Code</span>
var         <strong>shadowMapPlugin</strong> <a class="anchor-link"
            href="#shadowMapPlugin"
            title="Permalink to WebGLRenderer.shadowMapPlugin">#</a>
        </h4>
        <div class="doc">

<pre class="source">
var shadowMapPlugin;
</pre>
</div>
</div>
<div class="field"><h4 id="shadowMapSoft">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>shadowMapSoft</strong> <a class="anchor-link"
            href="#shadowMapSoft"
            title="Permalink to WebGLRenderer.shadowMapSoft">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool shadowMapEnabled,
	shadowMapAutoUpdate,
	shadowMapSoft,
	shadowMapCullFrontFaces,
	shadowMapDebug,
	shadowMapCascade;
</pre>
</div>
</div>
<div class="field"><h4 id="sortObjects">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>sortObjects</strong> <a class="anchor-link"
            href="#sortObjects"
            title="Permalink to WebGLRenderer.sortObjects">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool sortObjects,
	autoUpdateObjects,
	autoUpdateScene;
</pre>
</div>
</div>
<div class="field"><h4 id="stencil">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>stencil</strong> <a class="anchor-link"
            href="#stencil"
            title="Permalink to WebGLRenderer.stencil">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool alpha, 
		   premultipliedAlpha, 
		   antialias, 
		   stencil, 
		   preserveDrawingBuffer;
</pre>
</div>
</div>
<div class="field"><h4 id="supportsBoneTextures">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>supportsBoneTextures</strong> <a class="anchor-link"
            href="#supportsBoneTextures"
            title="Permalink to WebGLRenderer.supportsBoneTextures">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool supportsVertexTextures,
	   supportsBoneTextures;
</pre>
</div>
</div>
<div class="field"><h4 id="supportsVertexTextures">
<span class="show-code">Code</span>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>supportsVertexTextures</strong> <a class="anchor-link"
            href="#supportsVertexTextures"
            title="Permalink to WebGLRenderer.supportsVertexTextures">#</a>
        </h4>
        <div class="doc">

<pre class="source">
bool supportsVertexTextures,
	   supportsBoneTextures;
</pre>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        
        <div class="footer">
          <div>This page was generated at 2012-10-01 16:04:44.993</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
